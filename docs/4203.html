<html>
<head>
<title>Stanford CoreNLP: Training your own custom NER tagger.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯坦福CoreNLP:训练你自己的定制NER tagger。</h1>
<blockquote>原文：<a href="https://medium.com/swlh/stanford-corenlp-training-your-own-custom-ner-tagger-8119cc7dfc06#2018-05-02">https://medium.com/swlh/stanford-corenlp-training-your-own-custom-ner-tagger-8119cc7dfc06#2018-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c60e0c4d28ccee7fd07bd872febebe7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DOjzbKWtAGHfIPYilAFYw.png"/></div></div></figure><div class=""/><div class=""><h2 id="d29b" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">Java中的一个端到端的例子，使用你自己的数据集来训练一个定制的NER标记器。</h2></div></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><p id="e80b" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">斯坦福核心NLP是迄今为止最久经考验的NLP库。在某种程度上，它是当今NLP性能的黄金标准。在各种其他功能中，命名实体识别(NER)在库中得到支持，它允许在一段文本中标记重要的实体，如人名、地名等。</p><p id="671e" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">核心的自然语言处理NER标记器实现了条件随机场算法，这是解决自然语言处理中NER问题的最好方法之一。该算法在标记数据集上训练，输出是学习模型。</p><h1 id="85ba" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">预训练模型</h1><p id="d8c7" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">基本上，该模型学习训练数据中的信息和结构，并可以使用这些信息和结构来标记看不见的文本。CoreNLP附带了一些预训练的模型，如英语模型，这些模型被训练成用于检测姓名、地点等的结构化英语文本。</p><h1 id="3957" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">训练你自己的模型</h1><p id="eccd" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">但是，如果您的领域或用例中的文本与构建预训练模型的领域不重叠，那么预训练模型可能不太适合您。在这种情况下，您可以选择构建自己的训练数据，并为您的用例训练一个自定义模型。</p><p id="efd1" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们将展示如何使用NER标记器来学习电子商务搜索查询中的实体。</p><p id="33dd" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在此获取在<a class="ae li" href="https://dataturks.com/projects/Mohan/Best%20Buy%20E-commerce%20NER%20dataset" rel="noopener ugc nofollow" target="_blank">下使用的数据集。</a></p><h1 id="4434" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">训练数据格式</h1><p id="551e" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">训练数据作为文本文件传递，其中每行是一个单词-标签对。该行中的每个单词都应该以类似“word\tLABEL”的格式进行标记，单词和标签名称由制表符“\t”分隔。对于一个文本句子，我们应该将它分解成单词，并在训练文件中为每个单词添加一行。为了标记下一行的开始，我们在训练文件中添加一个空行。</p><p id="18c3" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">以下是输入培训文件的示例:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7853" class="ls km ht lo b fi lt lu l lv lw">hp	Brand<br/>spectre	ModelName<br/>x360	ModelName</span><span id="a53f" class="ls km ht lo b fi lx lu l lv lw">home	Category<br/>theater	Category<br/>system	0</span><span id="2047" class="ls km ht lo b fi lx lu l lv lw">horizon	ModelName<br/>zero	ModelName<br/>dawn	ModelName<br/>ps4	0</span><span id="fcad" class="ls km ht lo b fi lx lu l lv lw">hoverboard	Category</span></pre><p id="ee97" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">注意:每个单词都需要一个标签。这里，对于我们不关心的单词，我们使用标签0。</p><h1 id="da16" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">构建训练数据集</h1><p id="0926" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">根据您的领域，您可以自动或手动构建这样的数据集。手动构建这样的数据集可能非常痛苦，像<a class="ae li" href="https://dataturks.com/projects/Dataturks/Demo%20POS%20Tagging%20Project" rel="noopener ugc nofollow" target="_blank"> Dataturks NER tagger </a>这样的工具可以帮助简化这个过程。</p><h1 id="d7c2" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">火车模型</h1><p id="9263" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">这里重要的类是<code class="du ly lz ma lo b">CRFClassifier</code>，它保存实际的模型。下面是从训练数据文件构建模型并在文件中输出模型的代码。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="0391" class="ls km ht lo b fi lt lu l lv lw">public void trainAndWrite(String modelOutPath, String prop, String trainingFilepath) {<br/>   Properties props = StringUtils.propFileToProperties(prop);<br/>   props.setProperty("serializeTo", modelOutPath);</span><span id="73b5" class="ls km ht lo b fi lx lu l lv lw">   //if input use that, else use from properties file.<br/>   if (trainingFilepath != null) {<br/>       props.setProperty("trainFile", trainingFilepath);<br/>   }</span><span id="6ff1" class="ls km ht lo b fi lx lu l lv lw">   SeqClassifierFlags flags = new SeqClassifierFlags(props);<br/>   CRFClassifier&lt;CoreLabel&gt; crf = new CRFClassifier&lt;&gt;(flags);<br/>   crf.train();</span><span id="e8df" class="ls km ht lo b fi lx lu l lv lw">   crf.serializeClassifier(modelOutPath);<br/>}</span></pre><h1 id="3dfc" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">属性文件</h1><p id="d335" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">CoreNLP使用一个属性文件，我们可以在其中定义如何构建定制模型的参数。例如，我们可以定义如何构建要学习的特征等。下面是一个示例属性文件:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c2d3" class="ls km ht lo b fi lt lu l lv lw"># location of the training file<br/>trainFile = ./standford_train.txt<br/># location where you would like to save (serialize) your<br/># classifier; adding .gz at the end automatically gzips the file,<br/># making it smaller, and faster to load<br/>serializeTo = ner-model.ser.gz</span><span id="ac79" class="ls km ht lo b fi lx lu l lv lw"># structure of your training file; this tells the classifier that<br/># the word is in column 0 and the correct answer is in column 1<br/>map = word=0,answer=1</span><span id="6029" class="ls km ht lo b fi lx lu l lv lw"># This specifies the order of the CRF: order 1 means that features<br/># apply at most to a class pair of previous class and current class<br/># or current class and next class.<br/>maxLeft=1</span><span id="b050" class="ls km ht lo b fi lx lu l lv lw"># these are the features we'd like to train with<br/># some are discussed below, the rest can be<br/># understood by looking at NERFeatureFactory<br/>useClassFeature=true<br/>useWord=true<br/># word character ngrams will be included up to length 6 as prefixes<br/># and suffixes only<br/>useNGrams=true<br/>noMidNGrams=true<br/>maxNGramLeng=6<br/>usePrev=true<br/>useNext=true<br/>useDisjunctive=true<br/>useSequences=true<br/>usePrevSequences=true<br/># the last 4 properties deal with word shape features<br/>useTypeSeqs=true<br/>useTypeSeqs2=true<br/>useTypeySequences=true<br/>#wordShape=chris2useLC<br/>wordShape=none<br/>#useBoundarySequences=true<br/>#useNeighborNGrams=true<br/>#useTaggySequences=true<br/>#printFeatures=true<br/>#saveFeatureIndexToDisk = true<br/>#useObservedSequencesOnly = true<br/>#useWordPairs = true</span></pre><h1 id="3bff" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">从文件中读取模型</h1><p id="47b3" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">由于我们已经将模型保存到一个文件中，现在我们可以加载该模型(或者将它分发给其他人使用):</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3245" class="ls km ht lo b fi lt lu l lv lw">public CRFClassifier getModel(String modelPath) {<br/>    return CRFClassifier.getClassifierNoExceptions(modelPath);<br/>}</span></pre><h1 id="38d1" class="kl km ht bd kn ko kp kq kr ks kt ku kv iz kw ja kx jc ky jd kz jf la jg lb lc bi translated">使用模型做标记。</h1><p id="9cfb" class="pw-post-body-paragraph jp jq ht jr b js ld iu ju jv le ix jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">最后，我们可以看到该模型如何用于标记看不见的查询:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9b55" class="ls km ht lo b fi lt lu l lv lw">public void doTagging(CRFClassifier model, String input) {<br/>  input = input.trim();<br/>  System.out.println(input + "=&gt;"  +  model.classifyToString(input));<br/>}</span></pre><p id="14f0" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这是使用我们的模型的示例输出</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8b4c" class="ls km ht lo b fi lt lu l lv lw">String[] tests = new String[] {"apple watch", "samsung mobile phones", " lcd 52 inch tv"};<br/>for (String item : tests) {<br/>  doTagging(model, item);<br/>}</span></pre><p id="95e8" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">输出</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="445f" class="ls km ht lo b fi lt lu l lv lw">apple watch=&gt;apple/Brand watch/Category<br/>samsung mobile phones=&gt;samsung/Brand mobile/Category phones/Category<br/>lcd 52 inch tv=&gt;lcd/ModelName 52/ModelName inch/0 tv/Category</span></pre></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><p id="3904" class="pw-post-body-paragraph jp jq ht jr b js jt iu ju jv jw ix jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">无耻插件:我们是一个数据注释平台，让你建立ML数据集超级容易。只需上传数据，邀请您的团队，快速构建数据集。来看看我们吧。</p><h2 id="0e10" class="ls km ht bd kn mb mc md kr me mf mg kv jy mh mi kx kc mj mk kz kg ml mm lb mn bi translated"><a class="ae li" href="https://dataturks.com/index.php?s=blg" rel="noopener ugc nofollow" target="_blank">数据标注立易</a></h2></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><figure class="lj lk ll lm fd hk er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mo"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="48f8" class="ls km ht bd kn mb mc md kr me mf mg kv jy mh mi kx kc mj mk kz kg ml mm lb mn bi translated">这篇文章发表在《T4》杂志《创业》(The Startup)上，这是Medium最大的创业刊物，有320，924+人关注。</h2><h2 id="24b8" class="ls km ht bd kn mb mc md kr me mf mg kv jy mh mi kx kc mj mk kz kg ml mm lb mn bi translated">在这里订阅接收<a class="ae li" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="lj lk ll lm fd hk er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mo"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>