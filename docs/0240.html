<html>
<head>
<title>RxFlux Android Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxFlux Android架构</h1>
<blockquote>原文：<a href="https://medium.com/swlh/rxflux-android-architecture-94f77c857aa2#2015-10-20">https://medium.com/swlh/rxflux-android-architecture-94f77c857aa2#2015-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fd31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是关于新RxFlux框架的第一篇文章。是一个小型的轻量级框架，它使RxJava功能很容易遵循<a class="ae jd" href="https://facebook.github.io/flux/docs/overview.html" rel="noopener ugc nofollow" target="_blank">通量模式</a>。</p><p id="02a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于Flux是如何工作的我就不赘述了，为了更好的理解如何在Android中使用Flux pattern，<a class="ae jd" href="https://github.com/lgvalle" rel="noopener ugc nofollow" target="_blank"> @lgvalle </a>创造了一个很好的<a class="ae jd" href="https://github.com/lgvalle/android-flux-todo-app" rel="noopener ugc nofollow" target="_blank">例子和解释</a>。我会推荐之前看。</p><p id="79a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将解释如何使用RxFlux从头创建一个应用程序。如果你想了解如何使用RxFlux的更多具体细节，请访问repo。最后一点要注意的是，我使用了<a class="ae jd" href="https://github.com/evant/gradle-retrolambda" rel="noopener ugc nofollow" target="_blank"> Retrolambda </a>，因为用它一切看起来都很清楚。</p><div class="je jf ez fb jg jh"><a href="https://github.com/skimarxall/RxFlux" rel="noopener  ugc nofollow" target="_blank"><div class="ji ab dw"><div class="jj ab jk cl cj jl"><h2 class="hj b fi z dy jm ea eb jn ed ef hh bi translated">skimarxall/RxFlux</h2><div class="jo l"><h3 class="bd b fi z dy jm ea eb jn ed ef dx translated">RxFlux是一个小的框架，以遵循带有RxJava功能的Flux设计模式</h3></div><div class="jp l"><p class="bd b fp z dy jm ea eb jn ed ef dx translated">github.com</p></div></div><div class="jq l"><div class="jr l js jt ju jq jv jw jh"/></div></div></a></div><blockquote class="jx"><p id="db1c" class="jy jz hi hj ka kb kc kd ke kf kg jc dx translated">请以回购中的样本app作为参考。</p></blockquote><h1 id="4c9a" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">这个想法</h1><p id="ba0f" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在任何正常的应用程序开发中，第一步都是思考你想做什么。通量模式使得定义结构和指定期望的功能变得简单。</p><p id="12a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想要创建一个使用Github API的简单应用程序。这个应用程序向用户显示了一个存储库列表，用户可以查看所有者按下存储库项目。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lk"><img src="../Images/79ea39eb2840aa055a6ebfc056030696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGP7N8m7O93dxmVqriwAIw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Let’s keep this diagram in mind (author <a class="ae jd" href="https://github.com/lgvalle" rel="noopener ugc nofollow" target="_blank">@lgvalle</a>)</figcaption></figure><h1 id="1e33" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks lz ku kv kw ma ky kz la mb lc ld le bi translated">逻辑和功能</h1><p id="64c9" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们首先必须考虑的是我们需要哪些“商店”。在我们的情况下，我可以考虑:</p><ul class=""><li id="e7f6" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">RepositoriesStore:将包含GitHubRepos列表。</li><li id="dbc4" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">UsersStore:将包含我们为每个回购请求的用户列表。</li></ul><p id="5f65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据下面的图表，现在我们需要考虑我们应该定义什么接口，以便视图得到需要的信息。我们需要为每个商店创建一个界面。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es mq"><img src="../Images/496905c615145b44dba2aad53393f0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkZQj2VSuohkrkn9vWeU4w.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">We need to offer an interface for each store</figcaption></figure><p id="bc85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的回购商店是非常简单的，视图只需要列表。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="4f20" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public interface </strong>RepositoriesStoreInterface {<br/><br/>  List&lt;GitHubRepo&gt; getRepositories();<br/><br/>}</span></pre><p id="f7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了显示GitHubUser曾经点击过列表中的一个项目，我们需要通过id获取一个特定的用户，我们也可能对获取完整的用户列表感兴趣。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="d1bc" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public interface </strong>UsersStoreInterface {<br/><br/>  GitUser getUser(String id);<br/><br/>  List&lt;GitUser&gt; getUsers();<br/><br/>}</span></pre><p id="e71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们定义了模型，下一步就是思考哪些可能的动作是由应用程序行为或用户与应用程序的交互触发的。</p><p id="cd7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个RxAction由<strong class="ih nb"> <em class="nc">类型</em> </strong>和<strong class="ih nb"> <em class="nc">数据</em> </strong>(键值对)划分。</p><p id="0097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该应用程序需要的第一件事是请求回购列表，然后在用户按下其中一个项目的情况下，我们需要请求回购的用户信息。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="b8a9" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public interface </strong>Actions {<br/><br/>  String <strong class="ms nb"><em class="nc">GET_PUBLIC_REPOS </em></strong>= <strong class="ms nb">"get_public_repos"</strong>;<br/>  String <strong class="ms nb"><em class="nc">GET_USER </em></strong>= <strong class="ms nb">"get_user"</strong>;<br/><br/>  <strong class="ms nb">void </strong>getPublicRepositories();<br/><br/>  <strong class="ms nb">void </strong>getUserDetails(String userId);<br/>}</span></pre><p id="063c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建一个接口，它将包含由我们的RxActionCreator将实现的键和方法定义的所有可能的动作类型。</p><p id="c594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一部分是定义我们将在RxAction中的键-值对映射中使用的键。这些密钥将帮助我们在收到RxAction时检索数据。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="4819" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public interface </strong>Keys {<br/>  String <strong class="ms nb"><em class="nc">PUBLIC_REPOS </em></strong>= <strong class="ms nb">"repos"</strong>;<br/>  String <strong class="ms nb"><em class="nc">USER </em></strong>= <strong class="ms nb">"user"</strong>;<br/>  String <strong class="ms nb"><em class="nc">ID </em></strong>= <strong class="ms nb">"id"</strong>;<br/>}</span></pre><p id="7e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，主要功能、动作类型和模型被清楚地定义。如您所见，添加或删除逻辑就像定义新动作或删除它们一样简单。</p><h1 id="ca2d" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks lz ku kv kw ma ky kz la mb lc ld le bi translated">编码</h1><p id="cade" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">这就是我们可以与其他开发人员分担工作量(如果是这样的话)而不会互相干扰的一点。每个部分都是独立的。每个部分(存储、视图、动作……)都被定义和指定了什么必须返回，什么需要，因此我们可以分别实现每个部分的逻辑。</p><p id="5cb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从商店开始。我们创建了我们的RepositoriesStore，它扩展了RxStore并实现了我们的接口。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="877d" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public class </strong>RepositoriesStore <strong class="ms nb">extends </strong>RxStore <strong class="ms nb">implements </strong>RepositoriesStoreInterface {<br/><br/>  <strong class="ms nb">public static final </strong>String <strong class="ms nb"><em class="nc">ID </em></strong>= <strong class="ms nb">"RepositoriesStore"</strong>;<br/>  <strong class="ms nb">private </strong>ArrayList&lt;GitHubRepo&gt; <strong class="ms nb">gitHubRepos</strong>;<br/><br/>  @Override<br/>  <strong class="ms nb">public void </strong>onRxAction(RxAction action) {<br/>    <strong class="ms nb">switch </strong>(action.getType()) {<br/>      <strong class="ms nb">case </strong>Actions.<strong class="ms nb"><em class="nc">GET_PUBLIC_REPOS</em></strong>:<br/>        <strong class="ms nb">this</strong>.<strong class="ms nb">gitHubRepos </strong>= (ArrayList&lt;GitHubRepo&gt;) action.getData().get(Keys.<strong class="ms nb"><em class="nc">PUBLIC_REPOS</em></strong>);<br/>        <strong class="ms nb">break</strong>;<br/>      <strong class="ms nb">default</strong>: <em class="nc">// IMPORTANT if we don't modify the store just ignore<br/>        </em><strong class="ms nb">return</strong>;<br/>    }<br/>    postChange(<strong class="ms nb">new </strong>RxStoreChange(<strong class="ms nb"><em class="nc">ID</em></strong>, action));<br/>  }<br/><br/>  @Override<br/>  <strong class="ms nb">public </strong>ArrayList&lt;GitHubRepo&gt; getRepositories() {<br/>    <strong class="ms nb">return gitHubRepos </strong>== <strong class="ms nb">null </strong>? <strong class="ms nb">new </strong>ArrayList&lt;GitHubRepo&gt;() : <strong class="ms nb">gitHubRepos</strong>;<br/>  }<br/>}</span></pre><p id="07f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RxStore是一个抽象类，它提供了一些方法来发布事件，并将注册处理到dispatcher中。构造函数需要dispatcher作为参数，以便让RxFlux注册存储。</p><p id="d76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里重要的方法是反作用。每次调度程序将RxAction发送到总线时，都会调用此方法。每个商店将决定如何处理这一行动(使用或忽略)。</p><p id="bfa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们等待类型为<strong class="ih nb"> GET_PUBLIC_REPOS的动作。</strong>当我们得到这个动作时，我们从RxFlux的契约中知道，它将包含一个名为<strong class="ih nb"> PUBLIC_REPOS </strong>的键，以及我们的回购列表。对于我们简单的应用程序，我们只是将它存储在我们的变量中，并将存储更改发送到dispatcher。此商店更改需要一个ID和一个RxAction。调度程序将把这一更改发送到总线，视图将接收到它，并使用getRepositories方法对请求数据做出反应。</p><p id="2695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建一个动作来给出这个列表。再看看流程图，我们需要动作创建器。RxFlux提供了一个名为RxActionCreator的抽象类，它将帮助我们实现动作。普通构造函数需要dispatcher和SubscriptionManager作为参数。如果需要，我们还可以提供更多的参数。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="2b62" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public class </strong>GitHubActionCreator <strong class="ms nb">extends </strong>RxActionCreator <strong class="ms nb">implements </strong>Actions {<br/><em class="nc"><br/>  </em><strong class="ms nb">public </strong>GitHubActionCreator(Dispatcher dispatcher, SubscriptionManager manager) {<br/>    <strong class="ms nb">super</strong>(dispatcher, manager);<br/>  }<br/><br/>  @Override<br/>  <strong class="ms nb">public void </strong>getPublicRepositories() {<br/>    <strong class="ms nb">final </strong>RxAction action = newRxAction(<strong class="ms nb"><em class="nc">GET_PUBLIC_REPOS</em></strong>);<br/>    <strong class="ms nb">if </strong>(hasRxAction(action)) <strong class="ms nb">return</strong>;<br/><br/>    addRxAction(action, NetworkManager.<em class="nc">getApi</em>()<br/>        .getRepositories()<br/>        .subscribeOn(Schedulers.<em class="nc">io</em>())<br/>        .observeOn(AndroidSchedulers.<em class="nc">mainThread</em>())<br/>        .subscribe(repos -&gt; postRxAction(newRxAction(<strong class="ms nb"><em class="nc">GET_PUBLIC_REPOS</em></strong>, <strong class="ms nb"><em class="nc">PUBLIC_REPOS</em></strong>, repos)),<br/>            throwable -&gt; postError(action, throwable)));<br/>  }<br/>}</span></pre><p id="9b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHubActionCreator将实现我们之前定义的Actions接口。在这个方法中，我们将进行所有的“异步”工作(网络请求、解析等等)。首先我们需要创建动作，我们的动作很简单，没有参数，我们只需要调用<em class="nc">new RxAction(</em><strong class="ih nb"><em class="nc">GET _ PUBLIC _ REPOS</em></strong><em class="nc">)它</em>会给我们一个类型为<strong class="ih nb"> <em class="nc"> GET_PUBLIC_REPOS的新rx action。</em> </strong>下一步是检查我们是否已经在做这个动作，hasRxAction()会告诉我们这个动作是否存在并且正在运行。</p><p id="212a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们使用Retrofit和RxJava创建请求。这里没有什么特别的，我们请求我们订阅的存储库，然后我们需要实现订阅的onNext方法和onError方法。</p><p id="5777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当onNext方法返回新的回购列表时，我们将发布一个新的RxAction，其GET_PUBLIC_REPOS类型包含回购列表作为dispatcher的值。如果我们得到一个错误，我们将使用postError方法让商店和视图知道。</p><p id="19b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是创建视图并连接这些点。为了使这篇文章简短，我将跳过视图创建，只关注RxViewDispatch。这个接口必须由应用程序的每个活动来实现。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="ac61" class="mw ki hi ms b fi mx my l mz na"><strong class="ms nb">public interface </strong>RxViewDispatch {<br/><em class="nc"><br/>  </em><strong class="ms nb">void </strong>onRxStoreChanged(RxStoreChange change);<br/><br/>  <strong class="ms nb">void </strong>onRxError(RxError error);<br/><em class="nc"><br/>  </em><strong class="ms nb">void </strong>onRxViewRegistered();<br/><br/><em class="nc">  </em><strong class="ms nb">void </strong>onRxViewUnRegistered();<br/><em class="nc"><br/>  </em><strong class="ms nb">void </strong>onRxStoresRegister();<br/>}</span></pre><p id="46de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">java文档中解释了这些方法，但是它们非常清楚。</p><ol class=""><li id="ae08" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc nd mi mj mk bi translated">监听存储更改，我们通过存储id和操作类型来识别它们。</li><li id="ed18" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc nd mi mj mk bi translated">处理错误。</li><li id="7e13" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc nd mi mj mk bi translated">当视图从dispatcher注册或取消注册时得到通知，这样我们就可以注册其他类似片段的视图。</li><li id="5479" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc nd mi mj mk bi translated"><em class="nc"> onRxStoresRegister </em>是一个重要的方法，是商店的实例必须注册的地方。最好的方法是像dagger一样使用DI，获取store的实例并调用register方法。(注意:调度程序足够聪明，可以忽略商店是否已注册，因此您可以安全地注册多次)</li></ol><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="1d34" class="mw ki hi ms b fi mx my l mz na">@Override<br/><strong class="ms nb">public void </strong>onRxStoresRegister() {<br/>  <strong class="ms nb">repositoriesStore</strong>.register();<br/>  <strong class="ms nb">usersStore</strong>.register();<br/>}</span></pre><p id="a3b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用此方法后，两个商店都将在dispatcher中注册。如果您检查源代码，您会看到在活动的onCreate过程中调用了这个方法。RxFlux将处理注销。</p><h1 id="b71b" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks lz ku kv kw ma ky kz la mb lc ld le bi translated">连接最后一个点</h1><p id="754c" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">最后，在我们的应用程序实例中，我们只需要最后一样东西。我们必须初始化RxFlux类。该类将处理dispatcher、SubscriptionManager和RxBus的创建，还将处理应用程序的生命周期，以便注册和取消注册视图和存储，从而避免内存泄漏。</p><pre class="ll lm ln lo fd mr ms mt mu aw mv bi"><span id="1b71" class="mw ki hi ms b fi mx my l mz na">@Override<br/><strong class="ms nb">public void </strong>onCreate() {<br/>  <strong class="ms nb">super</strong>.onCreate();<br/>  <strong class="ms nb">rxFlux </strong>= RxFlux.<em class="nc">init</em>(this);<br/>}</span></pre><h1 id="ee55" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks lz ku kv kw ma ky kz la mb lc ld le bi translated">最终注释</h1><p id="1caa" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我跳过了几个方法，它可能看起来很复杂，但只要你稍微练习一下，我希望你会意识到这是一个很好的设计模式，它和RxJava一起为开发人员提供了创建应用程序的惊人工具，而且定义良好和清晰的结构使得扩展和添加额外功能变得非常容易，易于测试和添加新模块。例如跟踪，可以通过创建一个新的模块来完成，该模块注册到dispatcher中，监听所有的rx动作并跟踪结果。</p><p id="94bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该框架处于早期阶段，如果你决定开始使用它或有一些建议来改善它，我愿意接受公关或新的想法。</p><p id="6448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢它，请分享它，我也很乐意回答任何相关的问题。</p><p id="a575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！</p><p id="01bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Twitter上找到我:<a class="ae jd" href="https://twitter.com/marxallski" rel="noopener ugc nofollow" target="_blank">@ marxalski</a>和<a class="ae jd" href="https://plus.google.com/u/1/+MarcelPint%C3%B3" rel="noopener ugc nofollow" target="_blank"> Google+ </a></p><p id="3bf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前情提要:<a class="ae jd" rel="noopener" href="/@marxallski/rxflux-android-architecture-94f77c857aa2#.26yu2urap">反应式机器人形态</a></p></div></div>    
</body>
</html>