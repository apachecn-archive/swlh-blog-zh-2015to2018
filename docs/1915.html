<html>
<head>
<title>Autocomplete engine in Go: let’s build it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的自动完成引擎:让我们来构建它</h1>
<blockquote>原文：<a href="https://medium.com/swlh/autocomplete-engine-in-go-lets-build-it-1f8e9beb1b9e#2018-01-06">https://medium.com/swlh/autocomplete-engine-in-go-lets-build-it-1f8e9beb1b9e#2018-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b5bff9fdec76eea0858086b92e3ef3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ACfHlkxkI9ao7C-Z.png"/></div></div></figure><p id="f573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不久前，出于兴趣和好奇，我开发了一个小型的自动完成web服务。它的一部分包含了我在这篇文章中将要谈论的大部分内容。</p><p id="ab2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在Go中构建一个小型的完成提示器。</p><p id="2346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个实验，我有几个假设:</p><ul class=""><li id="bbd7" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">我们不关心子词匹配</li><li id="6996" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们想要一点打字错误的宽容</li><li id="75b0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们将进行不区分大小写的匹配</li></ul><h2 id="118b" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">基于前缀的映射</h2><p id="1452" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们将利用<a class="ae lc" href="https://github.com/alediaferia/prefixmap" rel="noopener ugc nofollow" target="_blank"> PrefixMap </a>，这是我的一个小Map实现，有助于基于前缀的键匹配。你可能在<a class="ae lc" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank">维基百科</a>上看到过这种叫做基数树、Trie或者前缀树的地图，但是我在Go land上找不到这种树的命名约定。也许你可以在评论里建议一个更好的名字。</p><p id="fca3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，基于前缀的地图将是我们提供建议的主要数据来源。我们将使用它来存储我们希望通过引擎匹配的所有建议。</p><h2 id="be79" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">莱文斯坦距离</h2><p id="3fdf" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们将使用<a class="ae lc" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein distance </a>作为度量来计算输入的字符串与我们找到的匹配有多远。特别是，我们将自己的相似性度量定义为:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="010b" class="kc kd hi li b fi lm ln l lo lp">           levenshtein(match,substr)<br/> 1.0  —   — — — — — — — — — — — — — — <br/>             max(|match|,|substr|)</span></pre><p id="9d76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du lq lr ls li b">substr</code>是输入的字符串，<code class="du lq lr ls li b">match</code>是我们找到的候选匹配。</p><p id="8515" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lq lr ls li b">1.0</code>的相似性意味着<code class="du lq lr ls li b">substr</code>和<code class="du lq lr ls li b">match</code>相等。</p><h2 id="f811" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">问题是</h2><blockquote class="lt lu lv"><p id="dc7c" class="iq ir lw is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">我们有一个输入可能匹配的字符串列表。我们希望找到一些符合我们定义的某个相似性阈值的候选匹配。</p></blockquote><p id="c652" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是当您开始在启用自动完成功能的输入字段中键入文本时所发生的事情的一个非常简化的版本。每次输入时，到目前为止，您输入的字符串都会根据数据源进行评估，以找到与您最相关的建议。所有这些都必须快速发生才能有效。您希望您的自动完成服务比正在键入的用户更快，这样他就可以节省时间并选择建议，而不是全部键入。</p><p id="1160" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这个特殊的原因，我们将要使用的前缀映射的实现将能够有效地找到给定前缀的所有值。这将使我们不必预先用给定键的所有可能的前缀填充更传统的映射。相反，由于树状结构值将被存储到映射中，我们将能够遍历树中共享一个公共前缀的值。</p><h2 id="7b12" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">示例解决方案</h2><p id="2e1d" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">对于这个具体的例子，我们的数据源将是一个世界国家的列表。我们的目标用户将不得不选择正确的国家，所以他们将开始输入，我们将提供一些建议，以节省他们的输入。</p><h2 id="272b" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">自动完成代码</h2><p id="0881" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">首先，让我们从低挂的水果开始。</p><p id="1d87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经定义了<em class="lw">相似性</em>的概念，所以我们将开始为它写一个函数。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="0d30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，该函数接受参数<code class="du lq lr ls li b">ld</code>作为输入之一。这就是我们想要知道相似度的单词之间的Levenshtein距离。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="1772" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们用现有的国家列表填充PrefixMap。出于练习的目的，我将使用由这个<a class="ae lc" href="http://www.countries-list.info/Download-List" rel="noopener ugc nofollow" target="_blank">在线服务</a>提供的英文国名列表，我已经将它转换成Go slice。你可以在这里找到它的要点<a class="ae lc" href="https://gist.github.com/alediaferia/0ca95bd099a5236b6a5cd676b00b7984" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c30e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经拥有了所有需要的东西，让我们来研究这个小程序的主要部分:匹配代码。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="c572" class="kc kd hi li b fi lm ln l lo lp">...<br/>        values := datasource.GetByPrefix(strings.ToLower(input))<br/>	results := make([]*Match, 0, len(values))<br/>	for _, v := range values {<br/>		value := v.(string)<br/>		s := similarity(len(value), len(input), LevenshteinDistance(value, input))<br/>		if s &gt;= similarityInput {<br/>			m := &amp;Match{value, s}<br/>			results = append(results, m)<br/>		}<br/>	}<br/><br/>	fmt.Printf("Result for target similarity: %.2f\n", similarityInput)<br/>	PrintMatches(results)<br/>...</span></pre><p id="e2aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们正在利用PrefixMap的<a class="ae lc" href="https://godoc.org/github.com/alediaferia/prefixmap#PrefixMap.GetByPrefix" rel="noopener ugc nofollow" target="_blank"> GetByPrefix </a>方法。<code class="du lq lr ls li b">GetByPrefix</code>将返回映射中属于指定前缀的所有值的展平集合。很方便，不是吗？</p><p id="c564" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我在这里应用的进一步过滤是相似性验证步骤。我正在浏览我们检索到的匹配列表，根据我们在程序中接收到的相似性输入对它们进行过滤。</p><p id="dee2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lw">你可以在</em><a class="ae lc" href="https://github.com/alediaferia/blog-examples/tree/master/go-autocompleter-example" rel="noopener ugc nofollow" target="_blank"><em class="lw">GitHub</em></a><em class="lw">上找到完整的实现示例。</em></p><h2 id="f0d5" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">输出</h2><p id="86b8" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">真的是这样。下面是我们刚刚编写的小代码的几个调用示例:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="850c" class="kc kd hi li b fi lm ln l lo lp">$ go run autocompleter.go -similarity 0.3 itlaly<br/><br/>Result for target similarity: 0.30<br/>match: 	Italy	similarity: 0.67</span><span id="4dfd" class="kc kd hi li b fi mc ln l lo lp">$ go run autocompleter.go -similarity 0.2 united<br/><br/>Result for target similarity: 0.20<br/>match: 	United Arab Emirates	similarity: 0.25	<br/>match: 	United Kingdom	similarity: 0.36	<br/>match: 	United States	similarity: 0.38</span><span id="44d9" class="kc kd hi li b fi mc ln l lo lp">$ go run autocompleter.go France<br/><br/>Result for target similarity: 0.30<br/>match: 	France	similarity: 1.00	<br/>match: 	Metropolitan France	similarity: 0.32</span></pre><h2 id="ce8e" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">进一步的改进</h2><p id="8f78" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">正如您所看到的，我们的小程序允许在某些情况下出现小的打字错误，除非它出现在我们输入的开始。这是因为我们使用了前缀Map，当然，如果我们以错误的前缀开始，它将不会匹配任何东西。这种意义上的改进可能是，在第一遍中没有找到指定相似性的匹配时，退回到全文搜索。</p><p id="8b1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇文章对你有所帮助，或者至少是有趣的。让我知道你是否需要任何澄清，或者如果你必须推荐一个更好的方法来实现这一点。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="4d75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lw">最初发表于</em> <a class="ae lc" href="https://alediaferia.com/2018/01/06/autocomplete-engine-go/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">一个dev的主线程</em> </a> <em class="lw">。</em></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">这篇文章发表在<a class="ae lc" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有281，454+读者。</h2><h2 id="7945" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">在这里订阅接收<a class="ae lc" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>