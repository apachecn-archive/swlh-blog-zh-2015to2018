<html>
<head>
<title>Get THREE times the capacity for your Kubernetes Cluster for FREE! Too good to be true?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">免费获得三倍于您的Kubernetes集群的容量！好得难以置信？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/get-three-times-the-capacity-for-your-kubernetes-cluster-for-free-too-good-to-be-true-6f0c3032c296?source=collection_archive---------0-----------------------#2018-11-08">https://medium.com/swlh/get-three-times-the-capacity-for-your-kubernetes-cluster-for-free-too-good-to-be-true-6f0c3032c296?source=collection_archive---------0-----------------------#2018-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几个月前，我在黑客新闻上看到一段<a class="ae jd" href="https://news.ycombinator.com/item?id=17241412" rel="noopener ugc nofollow" target="_blank">对话。一个海报假设你可以在一个</a><a class="ae jd" href="http://g.co/gke" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>集群中运行多个节点，价格与你使用<a class="ae jd" href="https://cloud.google.com/preemptible-vms/" rel="noopener ugc nofollow" target="_blank">可抢占虚拟机</a>的价格相同。</p><p id="d734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/products/calculator/#id=7b38b894-861c-4720-a477-15025f89f6d0" rel="noopener ugc nofollow" target="_blank">计算一下</a>，你可以以更低的价格获得3倍的容量，而且因为Kubernetes负责重新安排pod，你不必担心实例被抢占。听起来很棒，对吧？</p><p id="49fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我的个人经验和与多个高级GKE用户的交谈来看，这种节约成本的方法似乎确实有效。我实际上遇到过一个大型GKE客户(500多个节点),他们在100% PVM上运行所有无状态生产工作负载。他们报告说没有任何问题，并且对节省的成本非常满意。</p><p id="f09a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都准备好了吗？好吧，下一个评论攻击了这个想法，说<strong class="ih je">“你的信息明显暗示你对你所建议的东西没有经验，因此你没有意识到它的缺点。”</strong></p><p id="e47a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，好刺耳！这个人是对的吗？纯粹在PVM上运行您的工作负载是不是太疯狂了？或者，您真的可以获得3倍的容量而不会有任何负面影响吗？在网上争论只能让你到此为止，所以我决定亲自做一个测试。</p><p id="ee07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih je"><em class="jf">TL；DR: </em> </strong> <em class="jf">它工作的</em> <strong class="ih je"> <em class="jf">出奇的好</em> </strong> <em class="jf">，但是有很多注意事项，我只会在特定的情况下推荐给高级Kubernetes用户。</em> <strong class="ih je"> <em class="jf">一般来说，如果你在你的GKE集群中没有在某种程度上使用PVM，你可能会把钱留在桌子上。</em>T25】</strong></p><h1 id="8093" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">我们需要的数据</h1><p id="3168" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">为了以最可靠的方式进行测试，我想收集:</p><ol class=""><li id="1f4a" class="kj kk hi ih b ii ij im in iq kl iu km iy kn jc ko kp kq kr bi translated">在任何给定时间运行的吊舱的平均数量，</li><li id="0d77" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated">群集中的平均节点数</li><li id="6ba6" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated">豆荚数量最少</li><li id="b94c" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated">最少的节点数</li></ol><p id="e00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您可以在一个常规的GKE集群上运行10个pod，那么您应该能够以相同的价格在一个可抢占的GKE集群上运行30个相同的pod。但是如果PVM关闭如此频繁，以至于吊舱的平均数量少于10个，或者即使吊舱的最低数量低于10个，那么就会出现中断。对于节点来说也是一样:如果低于1，PVM将导致中断。</p><h1 id="722c" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">集群</h1><p id="2692" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">为了给我的集群最好的表现机会，我决定使用一个<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters" rel="noopener ugc nofollow" target="_blank"> GKE区域集群</a>。这些真的很酷，因为它们自动分布在一个区域的所有三个区域中，并为您提供多个主节点以实现高可用性。更重要的是，它可以防止特定区域中的PVM节点缺货，如果Google计算引擎系统需要更多虚拟机用于该区域中的标准节点，就会发生这种情况。</p><p id="19cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了两个集群，以便测试两种不同的场景。</p><p id="4c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个是三节点PVM集群，这是GKE集群的默认大小。但是因为它们都是PVM，所以这个集群比单个n1-standard-1实例更便宜。我想说，这种设置非常适合那些想要尝试一下或者正在运行测试工作负载，但是想要一个24/7运行的集群的人。</p><p id="c514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个是六节点PVM集群。这是三节点集群的两倍，但仍比标准虚拟机的三节点集群便宜30%。我觉得这对于生产系统来说是一个更现实的测试，因为理论上你可以将产能翻倍，同时降低成本。</p><h1 id="1274" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">数据收集</h1><p id="2b36" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">为了收集数据，我知道我必须把一些不同的服务放在一起。</p><p id="1a6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我需要从Kubernetes API实际收集统计数据。为此，我创建了一个公开REST端点的DaemonSet。这个DaemonSet将使用Kubernetes APIs来找出集群中运行了多少节点和单元。我选择使用DaemonSet，因为这是确保每个节点上始终有一个副本运行的简单方法，所以除非所有节点都宕机，否则我至少可以ping其中一个节点。</p><p id="23d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，我需要一些集群外的东西来实际ping这个DaemonSet并收集数据。为此，我使用了<a class="ae jd" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank">谷歌应用引擎</a>和<a class="ae jd" href="https://cloud.google.com/scheduler/" rel="noopener ugc nofollow" target="_blank">谷歌云调度器</a>服务。我使用cron服务每分钟运行一次我的应用程序引擎功能，但是我需要更多的粒度。所以，我在我的应用引擎函数中运行了一个循环，每秒执行60次。不是超级科学，但它的工作和简单的设置。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es kx"><img src="../Images/4b61377a28cabdad114969fc98f7465a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*OzX1Ph1h40P_eTMjnLjUyw.png"/></div></figure><p id="3299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是豆荚。我希望每个节点运行10个pods，所以我只使用了一个简单的nginx部署，并设置replicats = #Nodes x 10。</p><p id="6027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我需要一个地方来存储和查询这些数据。尽管它的大小只有100 MB，我还是使用了Google BigQuery，因为它是无服务器的，不需要任何设置，并且易于使用。我的模式非常简单，对于对DaemonSet的每次调用，我将存储pod、节点的数量，以及调用返回所需的等待时间。延迟时间在很大程度上取决于随机的网络条件，但我预计该时间在很低的秒范围内。</p><p id="56b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在到了无聊的部分。等待中。我需要至少一个月的数据才能做出任何声明。所以我把一切都部署好了，暂时忘了这件事。很长时间…</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="aee5" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">结果呢</h1><p id="d22b" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">你很幸运，我已经做了等待的部分！</p><p id="c17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们看看pod和节点的平均数量和最小数量是多少。我们可以通过一个简单的SQL查询来实现:</p><pre class="ky kz la lb fd lh li lj lk aw ll bi"><span id="b488" class="lm jh hi li b fi ln lo l lp lq">SELECT <br/>  avg(nodes) as avgnodes, <br/>  avg(pods) as avgpods, <br/>  min(nodes) as minnodes, <br/>  min(pods) as minpods<br/>FROM &lt;DATASET&gt;.&lt;TABLE&gt;</span></pre><p id="ad6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于三节点集群，结果如下:</p><pre class="ky kz la lb fd lh li lj lk aw ll bi"><span id="97b5" class="lm jh hi li b fi ln lo l lp lq">╔════════════════════╦═══════════════════╦══════════╦═════════╗<br/>║      avgnodes      ║      avgpods      ║ minnodes ║ minpods ║<br/>╠════════════════════╬═══════════════════╬══════════╬═════════╣<br/>║ 2.9984359359062274 ║ 29.99116207854014 ║        1 ║       0 ║<br/>╚════════════════════╩═══════════════════╩══════════╩═════════╝</span></pre><p id="d712" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于六节点集群:</p><pre class="ky kz la lb fd lh li lj lk aw ll bi"><span id="2836" class="lm jh hi li b fi ln lo l lp lq">╔═══════════════════╦═══════════════════╦══════════╦═════════╗<br/>║     avgnodes      ║      avgpods      ║ minnodes ║ minpods ║<br/>╠═══════════════════╬═══════════════════╬══════════╬═════════╣<br/>║ 5.996882929477012 ║ 60.00895171877486 ║        5 ║      30 ║<br/>╚═══════════════════╩═══════════════════╩══════════╩═════════╝</span></pre><p id="03fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这些数字中可以看出一些有趣的东西。首先，平均数字超级接近最大数字。这向我们展示了GKE从PVM节点关闭中恢复的速度非常快。记住，PVM总是在24小时后关闭，所以这些关闭事件一直在发生。</p><p id="e61a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jf">注意:六节点集群的avgpods略高于最大值。我认为这是因为一致性问题和pod处于待定状态或其他原因。不是100%确定。</em></p><p id="0f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一件事是最小数字。首先，很明显PVM引起了一些巨大的流失。对于较小的集群，我们下降到0，这是不好的。对于较大的集群，我们降到了最大值的一半，这一点也不差。请记住，我们正在以30%的低成本运行两倍的容量！</p><p id="15ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些数字只告诉了我们故事的一半。平均值和绝对最小值可能非常具有欺骗性。我们真正关心的是请求的分布，以及p50、p90和p99的延迟。因此，让我们编写一个新的SQL查询来给出这些数字。</p><pre class="ky kz la lb fd lh li lj lk aw ll bi"><span id="c54a" class="lm jh hi li b fi ln lo l lp lq">SELECT <br/>  latency, <br/>  count(*) as occurrences <br/>FROM (<br/>  SELECT <br/>    pods, <br/>    TIMESTAMP_DIFF(time, <br/>                   LAG(time) OVER (ORDER BY time ASC), <br/>                   SECOND<br/>    ) as latency <br/>  FROM &lt;DATASET&gt;.&lt;TABLE&gt; <br/>  ORDER BY time<br/>)<br/>GROUP BY delta <br/>ORDER BY delta DESC</span></pre><p id="7007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，这个查询要复杂得多(感谢BigQuery团队的同事们的帮助！)，但它给我们的结果是这样的:</p><pre class="ky kz la lb fd lh li lj lk aw ll bi"><span id="6177" class="lm jh hi li b fi ln lo l lp lq">+---------+-------------+<br/>| latency | occurrences |<br/>+---------+-------------+<br/>|      10 |          28 |<br/>|       9 |          39 |<br/>|       8 |          40 |<br/>|       7 |          54 |<br/>|       6 |          64 |<br/>|       5 |         100 |<br/>|       4 |         145 |<br/>|       3 |         258 |<br/>|       2 |         594 |<br/>|       1 |     2409521 |<br/>|       0 |     1812774 |<br/>+---------+-------------+</span></pre><p id="e340" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这告诉我们等待时间为零秒、一秒等的请求的数量。</p><p id="ff7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是所有数据和一些图表:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/a64eeb99e546420bae93d8dfc692a0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_xcGwEGW5gMf97efR3-aw.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx"><a class="ae jd" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vS_lGkkZnmHVMoCGQ35MtEfYrb9eLLbDysSC7_M3m3DO-1SDRw-vWUAn_fXAtvK8onqYU3QWEUpumHQ/pubhtml?gid=0&amp;single=true" rel="noopener ugc nofollow" target="_blank">See the data here</a></figcaption></figure><p id="657c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，绝大多数请求都在两秒以内，这很好。</p><p id="c429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，对于较小的集群，有一个需要200多秒才能完成的长尾请求。这显然是集群降到零节点的时候。</p><p id="d678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih je">这是真正酷的部分。两个集群的P99.9延迟仍然低于两秒！</strong></p><h1 id="4878" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">结论</h1><p id="8e25" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">PVMs在GKE的表现比我预期的要好很多。我原以为它们会很好，但它们会在很长一段时间内同时下跌。虽然较小的集群确实会出现这种情况，但较大的集群基本上足够大，可以很好地摆脱节点变动。</p><p id="0913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为大型集群中单个节点宕机的影响小于小型集群，所以我认为集群越大，这种变动影响工作负载的可能性就越小。</p><p id="5e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用PVMs还会在你的系统中创建一个自然的<a class="ae jd" href="https://en.wikipedia.org/wiki/Chaos_Monkey" rel="noopener ugc nofollow" target="_blank">混沌猴</a>。因为节点总是在变动，所以您的代码总是要接受弹性测试。这太棒了，因为您的基础设施为真正的中断做了更充分的准备。</p><p id="a3c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，运行有状态的工作负载(比如数据库)会复杂得多，甚至是不可能的。此外，由于潜在的风险，在PVM上运行需要尽可能长的正常运行时间的东西也更具挑战性。对于这两种场景，您可以轻松使用<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/node-pools" rel="noopener ugc nofollow" target="_blank"> GKE节点池</a>来创建可抢占和标准虚拟机的混合，以满足您的需求。</p><p id="a844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于自动化和规模经济，云的核心承诺一直是降低成本。我真的觉得如果你没有利用与GKE的PVMs，你就错过了那个承诺。</p><p id="18fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用PVM创建集群只需单击一个标志或按钮，您还在等什么？</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es ma"><img src="../Images/b365f174880e1a7e51a94778d343ff2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ly9_u9lPP9xydaCX"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">“group of people doing fist bumps” by <a class="ae jd" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rawpixel</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="84e3" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">最后一句话</h1><p id="8544" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">对于这个测试，我只关心正在运行的pod的数量。在现实生活中，您会有多个微服务，每个微服务都有自己的pod。如果单个微服务的所有pod都宕机，这是一个坏消息。您可以使用PodAffinity规则来确保这种情况不会发生。</p><p id="6b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文有一些关于PodAffinity的好细节:</p><p id="1d3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/kokster/scheduling-in-kubernetes-part-2-pod-affinity-c2b217312ae1">https://medium . com/kok ster/scheduling-in-kubernetes-part-2-pod-affinity-c2b 217312 AE 1</a></p><p id="c690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，一些微服务不能容忍PVM造成的持续流失。您应该使用NodeAffinity来确保这些微服务不会被调度到PVM上。</p><p id="cad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文有一些关于PVM的NodeAffinity的很好的细节:</p><div class="mb mc ez fb md me"><a rel="noopener follow" target="_blank" href="/google-cloud/using-preemptible-vms-to-cut-kubernetes-engine-bills-in-half-de2481b8e814"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="hj b fi z dy mj ea eb mk ed ef hh bi translated">使用可抢占的虚拟机将Kubernetes引擎账单削减一半</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">可抢占虚拟机的固定价格比常规虚拟机低80%,但不幸的是，它们的广告宣传主要针对…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">medium.com</p></div></div></div></a></div><figure class="ky kz la lb fd lc er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mn"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="lm jh hi bd ji mo mp mq jm mr ms mt jq iq mu mv ju iu mw mx jy iy my mz kc na bi translated">这篇文章发表在<a class="ae jd" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，有+388，456人关注。</h2><h2 id="869c" class="lm jh hi bd ji mo mp mq jm mr ms mt jq iq mu mv ju iu mw mx jy iy my mz kc na bi translated">订阅接收<a class="ae jd" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="ky kz la lb fd lc er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mn"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>