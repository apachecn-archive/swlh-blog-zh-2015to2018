# 错误也是特征

> 原文：<https://medium.com/swlh/errors-are-features-too-b4922c7d98f2>

![](img/6c81c06ec13fc82c68fc25a873d9a7c5.png)

没有人喜欢错误。

然而错误仍然存在。分段故障时有发生，蓝屏仍然是一件事，API 退回带有 5xx 状态代码的请求。没有人合理提供 100%的正常运行时间。

但是大多数时候，在测试新的 API 时，不太可能会遇到错误。在交付生产之前，您可能不会体验到它们。因此，对于包括 Pusher 在内的服务提供商来说，优化他们产品中的快乐路径是有意义的。

但是过于乐观会造成伤害——错误不会消失，忽视它们会产生负面反馈循环。

一切都始于一个糟糕的错误。处理该模块的下一个开发人员会忽略它，并在不重构错误处理逻辑的情况下进行快速更改。下面的开发者也是这么做的。这个循环持续一段时间，技术债务累积，最终导致…

> 应用程序遇到意外错误:无错误。

如何才能打破这种恶性循环？我们能以同样的尊重对待软件错误和快乐之路吗？

在 Pusher，我们认为错误是特征。我们认为它们应该得到和快乐场景一样多的关注。

为了解释这一理念，我们将其转化为错误设计的五个原则:

1.  针对客户端简单性进行优化。
2.  考虑处理程序的设计错误。
3.  抽象应该减少错误率。
4.  提前失效，安全失效。
5.  提供可操作的错误细节。

它们不仅减少了处理错误的挫折感，还提高了我们服务的可靠性。

# 1.针对客户端简单性进行优化

Pusher 的目标是用更简单、更易管理的接口将复杂的通信问题封装到服务中。这种将复杂性转移到服务器的理念减少了我们客户的工作量，帮助他们用更少的代码完成更多的工作。

遵循这条规则，**我们必须保持简单的客户端错误处理行为**。我们需要将客户端和服务器之间交互的复杂性降到最低。保持协议和 API 契约简单是至关重要的。

这个原则有几个好处。

首先，该服务有一个后端实现，但它被许多客户端库使用。通过减少客户端的逻辑数量，我们可以节省大量的工程时间。

第二，服务器通常更了解故障的起源。它们可以为客户提供更好的指导，减少将系统恢复到正常工作状态的时间。

最后，对复杂的网络交互进行故障排除非常困难。用一个简单的接口将该逻辑封装到一个组件中，使得客户端和服务器维护人员的调试更加容易。

# 2.考虑处理程序的设计错误

大多数错误都出现在遇到故障的层中。有一个扩展 StandardException 的类，一个处理边缘情况的 if 条件，或者一个 throw 语句。单元测试通过。任务完成。

**开发人员忘记了必须有人来处理这个错误。**

我们必须在设计错误时考虑到它们的接收者。然而，确定适当的抽象来处理它们是困难的。

哪些组件关心错误？他们是直接接收还是通过其他层接收？他们会补救失败还是升级失败？应用程序会向最终用户显示错误吗？怎么会？

找到并回答这些问题是困难的，但从长远来看，这对每个人都有好处。

# 3.抽象应该减少错误率

好的抽象使系统更简单。我们没有封装组件来使最终的接口更难理解。至少我们尽量不这么做。

我发现错误率是判断抽象价值的一个重要指标。最好的抽象不会产生错误，但是分布式系统不能那样操作。

对于单个错误类别，比率可以:

1.  通过过滤误差来减少
2.  通过进一步传递所有错误，保持在同一水平
3.  通过放大误差来增加

降低错误率的抽象是有用的。

**提高错误率的抽象表示有问题。**

有些抽象根本不处理错误，这也没什么。例如，在格式之间转换值——假设映射不会失败——不会改变错误率，但仍然有用。

# 4.早期故障，故障安全

对 Pusher 的每个请求都要经过我们堆栈的几层。首先，它攻击外部负载平衡器，然后是内部代理、服务本身，最终变成数据库操作。

在设计良好的系统中，每个抽象层都可以更深入地挖掘请求。边缘代理，如 AWS ELB，工作在 TCP 层——它们不理解 HTTP，WebSockets，更不用说服务逻辑了。我们的中间代理使用 HTTP，但是它们不关心服务逻辑。

抽象层也可能引入新的副作用。当请求在到达内部代理之前失败时，我们知道它没有触及服务的数据库。相反，当服务在接受请求和返回响应之间消失时，我们不能保证服务没有修改它的数据库。

**尽早终止请求很重要，这样可以防止请求导致不一致和产生处理成本。每个错误应该来自最外层，它有足够的上下文来处理失败。例如，TCP 负载平衡器不能限制请求速率，因为它们不理解 HTTP。然而，我们的内部代理支持 HTTP 并知道适当的速率限制，因此它们可以限制处理的请求数量。**

这种方法增加了安全重试请求的数量，让客户端在不牺牲数据一致性的情况下进行恢复。

# 5.提供可操作的错误细节

老实说，我们不能处理所有的错误。有时无效数据会通过 SDK。有时，如果没有人工干预，客户将无法解决不一致的问题。

在这些情况下，**提供足够的关于错误条件**的人类可读细节是很重要的。仅仅有类名是不够的。人们需要错误类型、描述、参数，或者更好的解决问题的步骤。

**这些细节必须是可操作的。**如果用户提交了无效的数据，服务应该提供纠正它的步骤。如果请求格式不正确，错误消息应该指出这很可能是客户端库的错误，开发人员应该向维护人员报告。

然而，**避免不必要的细节至关重要。**如果我们的数据库关闭，用户只能稍后重试请求。他们不应该知道内部服务与其数据库之间存在连接故障。他们需要知道错误是暂时的。

我们需要设计协议、API、SDK 和其他工具来始终提供这些信息。在这方面的失败意味着开发人员会将问题升级到支持，甚至会因为失望而放弃服务。

# 爱你的错误

理论上，错误几乎不存在。事实上，他们可以像定义实际功能一样定义开发者体验。

上面概述的五个原则定义了 Pusher 的错误哲学，但它们符合我们为实时平台设计所有功能的方法:

*   我们为客户的简单性而优化。
*   我们在设计功能时考虑到了最终用户。
*   我们添加抽象来减少下游的工作量。
*   我们试图尽早处理业务逻辑。
*   我们还为功能提供可操作的文档。

API 应该为他们的用户服务。即使它们不起作用。

[![](img/308a8d84fb9b2fab43d66c117fcc4bb4.png)](https://medium.com/swlh)

## 这篇文章发表在 [The Startup](https://medium.com/swlh) 上，这是 Medium 最大的创业刊物，有 333，853+人关注。

## 订阅接收[我们的头条新闻](http://growthsupply.com/the-startup-newsletter/)。

[![](img/b0164736ea17a63403e660de5dedf91a.png)](https://medium.com/swlh)