<html>
<head>
<title>Garbage Collection vs. Automatic Reference Counting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">垃圾收集与自动引用计数</h1>
<blockquote>原文：<a href="https://medium.com/swlh/garbage-collection-vs-automatic-reference-counting-49154436966e#2018-02-11">https://medium.com/swlh/garbage-collection-vs-automatic-reference-counting-49154436966e#2018-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/002aae8b2640ccb6a5f544da41f7a317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZK1D3GDz_ATMCHSzL2lYLw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/photos/YzSZN3qvHeo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Gary Chan</a> on <a class="ae iu" href="https://unsplash.com/search/photos/garbage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8d81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在之前的<a class="ae iu" rel="noopener" href="/@m.tabrizi/memory-management-in-swift-3c38065ecbbd">博文</a>中，我们看到了iOS是如何使用自动引用计数(ARC)作为其对象生存期管理系统的。在这篇文章中，我试图指出ARC与垃圾收集或者更具体地说<a class="ae iu" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank">跟踪垃圾收集</a>的一些显著区别(更准确地说，引用计数和跟踪是垃圾收集的两种不同实现。换句话说，ARC是垃圾收集的一种形式。由于<em class="jt">跟踪垃圾收集</em>是最常见的垃圾收集类型，通常术语“垃圾收集”是指跟踪垃圾收集)。</p><h1 id="3571" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">自动引用计数</h1><p id="ac18" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/@m.tabrizi/memory-management-in-swift-3c38065ecbbd"> ARC </a>是一个<a class="ae iu" href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" rel="noopener ugc nofollow" target="_blank">编译器特性</a>使用<em class="jt">对象所有权。</em>如果对象的<a class="ae iu" href="https://en.wikipedia.org/wiki/Reference_counting" rel="noopener ugc nofollow" target="_blank">引用计数</a>为零，即不再有所有者，ARC将从内存中释放对象，而不是在运行时在后台查找未使用的对象。ARC在编译时自动注入Objective-C运行时等价的retain、release(编译器在所有需要的地方插入retain和release)。我有一整篇<a class="ae iu" href="http://developer-toolbox.blogspot.com/2017/08/swift-memory-management.html" rel="noopener ugc nofollow" target="_blank">帖子</a>解释ARC是如何工作的。</p><h2 id="968b" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated"><strong class="ak">自动引用计数的优势</strong></h2><ul class=""><li id="6ad2" class="ll lm hi ix b iy ks jc kt jg ln jk lo jo lp js lq lr ls lt bi translated">对象的销毁是实时的和可预测的。它有<em class="jt">确定性的</em>对象回收(当最后一个对该对象的强引用消失时)，而GC在“某个时候”释放一个对象。一旦对象不再被引用，就会被释放，而无需长时间暂停收集周期。这使得对象可以更快地被释放。这对于移动设备等内存有限的系统非常重要。这定义了一类微妙的bug，它们可能存在于GC应用程序中，由于收集器不会在“错误窗口”中触发，所以不会暴露出来。</li><li id="dbb7" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">没有后台处理，这使得它对于低功耗系统来说效率更高。</li><li id="0f6f" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">如果活动对象集填满了大部分可用内存，跟踪垃圾收集周期就会被频繁触发，这就需要额外的空间来提高效率。随着可用空间总量的减少，引用计数性能不会下降。</li><li id="8b36" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">引用计数的渐近复杂性不依赖于堆的总大小。</li></ul><h2 id="594f" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated"><strong class="ak">自动参考计数的缺点</strong></h2><ul class=""><li id="5c3d" class="ll lm hi ix b iy ks jc kt jg ln jk lo jo lp js lq lr ls lt bi translated">无法收集保留周期。保留周期保持引用计数大于零，即使它们不可达</li><li id="8ab5" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">需要考虑多线程引用计数。</li></ul><h1 id="1d80" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">碎片帐集</h1><p id="d76c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" rel="noopener ugc nofollow" target="_blank">垃圾收集</a> (GC)是一种自动内存管理的形式，试图回收垃圾，或者程序不再使用的对象所占用的内存。在存在任何垃圾收集之前，您必须手动添加对retain和release的调用(在其他语言中为“free”或“destroy”)。</p><p id="cbff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几种<a class="ae iu" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Strategies" rel="noopener ugc nofollow" target="_blank">策略</a>来实现垃圾收集，最常见的两种是跟踪和引用计数。跟踪垃圾回收由。NET和Java平台。</p><p id="bc26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">垃圾收集在运行时进行。它检测未使用的对象，一旦你的代码不再使用它们，它就释放它们。这发生在<em class="jt">不确定的</em>时间间隔(或者在一定时间过去后，或者当运行时发现可用内存变低时)，因此对象不一定在不再被使用时被释放。</p><h2 id="38bb" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">垃圾收集的优势</h2><ul class=""><li id="0ff7" class="ll lm hi ix b iy ks jc kt jg ln jk lo jo lp js lq lr ls lt bi translated">GC可以清理整个对象图，包括保留循环。这是垃圾收集相对于ARC的主要优势，您不需要担心保留周期。</li><li id="e824" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">GC发生在后台，所以作为常规应用程序流的一部分，完成的内存管理工作较少。</li></ul><h2 id="c17d" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">垃圾收集的缺点</h2><ul class=""><li id="3cd1" class="ll lm hi ix b iy ks jc kt jg ln jk lo jo lp js lq lr ls lt bi translated">因为GC发生在后台，所以对象释放的确切时间框架是不确定的。</li><li id="e142" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">当GC发生时，应用程序中的其他线程可能会被暂时挂起。</li></ul><h1 id="7670" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">继续教育</h1><p id="04f3" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><a class="ae iu" href="https://docs.elementscompiler.com/Concepts/ARCvsGC/" rel="noopener ugc nofollow" target="_blank"> ARC vs. GC </a> <br/> <a class="ae iu" href="https://lists.apple.com/archives/objc-language/2011/Jun/msg00013.html" rel="noopener ugc nofollow" target="_blank">苹果Objective-C邮件列表上的一个线程</a> <br/> <a class="ae iu" href="https://www.ibm.com/developerworks/java/library/j-jtp10283/" rel="noopener ugc nofollow" target="_blank">垃圾收集简史</a></p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">这个故事发表在<a class="ae iu" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有295，232+人关注。</h2><h2 id="7945" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">在这里订阅接收<a class="ae iu" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>