<html>
<head>
<title>How to build a Tiny URL service that scales to billions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个规模达到数十亿的微小URL服务？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/how-to-build-a-tiny-url-service-that-scales-to-billions-f6fb5ea22e8c?source=collection_archive---------0-----------------------#2018-10-20">https://medium.com/swlh/how-to-build-a-tiny-url-service-that-scales-to-billions-f6fb5ea22e8c?source=collection_archive---------0-----------------------#2018-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ef24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这个故事最初发表在我的博客@linqz.io </em> <a class="ae je" href="https://www.linqz.io/2018/10/how-to-build-a-tiny-url-service-that-scales-to-billions.html" rel="noopener ugc nofollow" target="_blank"> <em class="jd">这里</em> </a> <em class="jd">。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/fe6f54a746083c866c94134e57fbe72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*-XvKtTo7CV2FKtZ8ht-JNA.png"/></div><figcaption class="jn jo et er es jp jq bd b be z dx">How to build a Url Shortner service ?</figcaption></figure><p id="bfef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Twitter的设计限制之一是每条消息被限制在140个字符以内，但如果你像我一样喜欢在Twitter消息中发布URL，那140个字符就变得非常昂贵。这可能就是为什么<strong class="ih jr"> Twitter使用</strong><a class="ae je" href="http://tinyurl.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ih jr">TinyUrl</strong></a><strong class="ih jr">服务或任何其他服务</strong>自动将任何超过30个字符的Url转换为短URL。后来，市场上出现了许多url缩短服务，即Bitly、Google Url Shortner、Rebrandly等。许多企业也开始在各种渠道的营销活动、广告活动等中使用它们。</p><p id="4abb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">为URL创建一个唯一的、可重复的标识符</strong> <br/>我想很多人的第一反应可能是散列URL字符串——但这不是一个好主意，原因如下:</p><ul class=""><li id="ff9c" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">长度:大多数普通的散列算法(比如md5)会产生很长的字符串，这有点违背了url缩短的目的。</li><li id="8d35" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">唯一性:显然，如果这将是一个URL标识符，那么它需要是唯一的，而哈希本质上并不是唯一的——这意味着您需要处理URL创建了一个已经使用的哈希并且有一个替代项的情况。</li><li id="ed2d" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">查找:大多数散列是不可逆的，您需要使用散列作为db键来查找URL——这对于一个非常大的URL集(想象一下几十亿)来说可能并不理想</li></ul><p id="3685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天我们将讨论如何构建和开发一个微型url服务。首先，让我们分成3个部分，算法，设计和如何扩展及其复杂性。</p><h1 id="e3d1" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">算法:</h1><p id="6895" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">我们有62个字母数字字符，即[A-z0–9 A-Z]，尽管在url中允许使用连字符(-)和下划线(_)，但我们仍然希望避免使用它们，因为这将是一个难看的url，如<a class="ae je" href="http://xyz.com/c0--rw_" rel="noopener ugc nofollow" target="_blank">http://abc.com/<strong class="ih jr">c0-rw _</strong>T22】或</a><a class="ae je" href="http://xyz.com/______-." rel="noopener ugc nofollow" target="_blank">http://abc.com/<strong class="ih jr">_ _ _ _ _ _-。</strong> </a> <br/>下面是base10到base62转换器的简单实现，这就是我们缩短一个url所需要的全部内容。</p><p id="dce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了62个字符和一个7，8，9，10，11字符长的唯一字符串，我们可以缩短:</p><blockquote class="lj lk ll"><p id="9aea" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih jr"><em class="hi">62⁷= 3521614606208</em></strong><em class="hi">网址</em></p><p id="8277" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih jr"><em class="hi">62⁸=</em>218340105584896</strong><em class="hi">网址</em></p><p id="f8ca" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih jr"><em class="hi">62⁹=</em>13537086546263552</strong><em class="hi">网址</em></p><p id="c112" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih jr"><em class="hi">62⁰=</em>839299365868340224</strong><em class="hi">网址</em></p><p id="fb49" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih jr"><em class="hi">62 =</em>52036560683837093888</strong><em class="hi">网址</em></p></blockquote><p id="478d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以你可以从上面看到，我们可以生成这些62⁶= ~ 50亿个可能的字符串&amp; 62⁸ = ~218万亿个可能的字符串，还可以根据需要生成更多。</p><p id="ef2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，让我们说，我们决定要为下面的链接生成缩短的网址</p><blockquote class="lj lk ll"><p id="14d0" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><a class="ae je" rel="noopener" href="/@vaibhav0109/cache-refreshing-techniques-446403de1ba2">https://medium . com/@ vaibhav 0109/cache-refreshing-techniques-446403 D1 ba 2</a></p></blockquote><p id="042f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们将使用base 62生成一个唯一的id，把它附加到我们的托管域，假设生成的id是<code class="du lp lq lr ls b">qa12WS4</code>，我们假设的托管域是<code class="du lp lq lr ls b">http://short.io</code>，那么我的小url就变成了<code class="du lp lq lr ls b">http://short.io/qa12WS4</code></p><p id="3ea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们只需要确保这个链接是唯一的，不会被再次分配，我们将在本博客的后面部分讨论如何存储的策略。</p><p id="90bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是可用于生成唯一字符串的两个函数:</p><pre class="jg jh ji jj fd lt ls lu lv aw lw bi"><span id="ce4e" class="lx kh hi ls b fi ly lz l ma mb">private static final char[] corpus   = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toCharArray();</span><span id="f9dc" class="lx kh hi ls b fi mc lz l ma mb">/*<br/>* Note if seed is unique then generated base62 number will be unique as well under load balance make sure this value is not same.<br/>*/<br/>public static final String getBase62From10(final long seed)<br/>{<br/>  String number = seed + "";<br/>  char[] buf = new char[number.length()];<br/>  int charPos = number.length() - 1;<br/>  BigInteger bigIntegerNumber = new BigInteger(number);<br/>  BigInteger radix = BigInteger.valueOf(62);<br/> <br/>  while (bigIntegerNumber.compareTo(radix) &gt;= 0)<br/>  {<br/>   buf[charPos--] = corpus[bigIntegerNumber.mod(radix).intValue()];<br/>   bigIntegerNumber = bigIntegerNumber.divide(radix);<br/>  }<br/>  buf[charPos] = corpus[bigIntegerNumber.intValue()];<br/>  return new String(buf, charPos, (number.length() - charPos));<br/>}<br/>/**<br/>* @param longNumber<br/>* a positive number in base 62<br/>* @return the same number, in base 10<br/>*/<br/>public static final String getBase10From62(final long longNumber)<br/>{<br/>  String number = longNumber + "";<br/>  BigInteger value = BigInteger.ZERO;<br/>  for (char c : number.toCharArray())<br/>  {<br/>    value = value.multiply(BigInteger.valueOf(62)); <br/>    if ('0' &lt;= c &amp;&amp; c &lt;= '9')<br/>    {<br/>      value = value.add(BigInteger.valueOf(c - '0'));<br/>    }<br/>    if ('a' &lt;= c &amp;&amp; c &lt;= 'z')<br/>    {<br/>      value = value.add(BigInteger.valueOf(c - 'a' + 10));<br/>    }<br/>    if ('A' &lt;= c &amp;&amp; c &lt;= 'Z')<br/>    {<br/>      value = value.add(BigInteger.valueOf(c - 'A' + 36));<br/>    }<br/>   }<br/>   return value.toString();<br/>}</span></pre><h1 id="01df" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">设计:</h1><p id="a2df" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">现在让我们转到应用程序的设计部分。根据系统的负载或者应用程序是否在负载均衡器之后，可以有多种方法。首先是最简单的，其次是对第一种的改进。</p><p id="a458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最简单的情况下，我们可能可以通过以下几列:</p><ul class=""><li id="a867" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">id(数据库生成的序列ID)</li><li id="8aeb" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">原始url-原始URL值</li><li id="eef4" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">缩短_url</li><li id="a30f" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">创建日期</li><li id="4ebc" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">到期日期</li></ul><p id="d2aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">从数据库生成标识符</strong></p><ol class=""><li id="6a7c" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc md jy jz ka bi translated">现在，如果您提供一个字符串URL值，您的代码只需要将它和创建日期一起插入到表中，这将创建行和惟一的ID。</li><li id="c87b" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc md jy jz ka bi translated">接下来，获取唯一的数字ID，并将其转换为base-62(这将把数值转换为base-62表示(而不是普通的base10，它将允许0–9、a-z、A-Z作为字符)。这为您提供了一个形式为<code class="du lp lq lr ls b">qa12WS4</code>的标识符。</li><li id="a7bb" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc md jy jz ka bi translated">现在，将base62字符串添加到您的短域名<code class="du lp lq lr ls b">http://short.io</code>的基本url中，瞧，您得到一个缩短的url作为<code class="du lp lq lr ls b">http://short.io/qa12WS4</code>，并将其更新到短url列中，并注明到期日期。</li><li id="fd14" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc md jy jz ka bi translated">现在你只需要编写重定向逻辑，因为谁点击了这个缩短的url，你就从Db中获取详细信息，并将其重定向到原始Url。</li></ol><p id="d590" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法有两个缺点:</p><ul class=""><li id="3681" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">首先，我们做了两个数据库操作，插入和更新，在高负载下它不会伸缩。</li><li id="4a55" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">其次，在数据库迁移的情况下，序列id不能被合并，因为我们可能将相同的序列id生成到两个表中。</li></ul><p id="a1c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来讨论一下改进，我们可以改进两件事，首先是数据库结构，其次，我们可以只进行单次插入，而不是插入和更新。数据库结构如下:</p><ul class=""><li id="335e" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">id_hash (base 62生成的字符串作为主键)</li><li id="e468" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">原始_url</li><li id="826b" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">缩短_url</li><li id="0567" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">创建日期</li><li id="429a" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">到期日期</li></ul><p id="efbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，要将id_hash作为主键，我们需要一个集中式服务，它为我提供唯一的种子令牌，例如，我们使用Redis自动增量功能(因为它本质上是原子的),我们可以获得一个种子编号并生成一个base 62字符串，这也将在负载平衡下的两个实例中工作。根据需求，可以构建多种方法来获得独特的种子。</p><h1 id="54bd" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">该系统的规模和复杂性:</h1><p id="cae3" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated"><strong class="ih jr">流量估计:</strong>对于每月5亿个新的网址缩短，我们可以预计在同一时期会有(100 * 500M = &gt; 50B)个重定向。我们系统的每秒查询数(QPS)是多少？</p><p id="0586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每秒新的URL缩写:</p><p id="5604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a) 5亿/ (30天* 24小时* 3600秒)= ~ 192个URLs秒</p><p id="2f93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b) 10亿/ (30天* 24小时* 3600秒)= ~386个网址/秒</p><p id="cc87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每秒URL重定向数，考虑100:1的读/写比:</p><p id="ad7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a) 100 * 5亿= 500亿次重定向</p><p id="d689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">500亿/ (30天* 24 * 3600 ) = ~ 19K/s</p><p id="eab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b) 100 * 10亿= 1000亿次重定向</p><p id="47cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1000亿次/ (30天* 24小时* 3600秒)= ~ 38K/秒</p><p id="8df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">存储估计:</strong>假设我们将每个URL缩短请求(以及相关的缩短链接)存储了2年。由于我们预计每个月会有10亿个新URL，因此我们预计要存储的对象总数将达到300亿:</p><p id="d271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10亿* 2年* 12个月= 240亿</p><p id="a22a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设每个存储的对象大约为500字节(这只是一个大概的估计——我们稍后会深入研究)。我们将需要15TB的总存储空间:</p><p id="6fd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">240亿* 500字节= 12 TB</p><p id="d577" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">带宽估计:</strong>对于写请求，由于我们预计每秒钟有386个新URL，我们服务的总传入数据将为每秒100KB:</p><p id="be07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">386 * 500字节=约200 KB/秒</p><p id="cc39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于读取请求，由于每秒钟我们预计大约19K的URL重定向，我们服务的总传出数据将为每秒9MB。</p><p id="38d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">38K * 500字节=约18mb/秒</p><p id="0c0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">内存估计:</strong>如果我们想缓存一些经常访问的热门网址，我们需要多少内存来存储它们？如果我们遵循80–20规则，也就是说20%的URL产生80%的流量，我们会缓存这20%的热门URL。</p><p id="757c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们每秒有38，000个请求，所以我们每天会收到34亿个请求:</p><p id="0fda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">38 K * 3600秒* 24小时= ~ 34亿</p><p id="d9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了缓存20%的请求，我们需要340GB的内存。</p><p id="8de3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">0.2 * 34亿* 500字节=约340 GB</p><p id="4a44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，既然我们对规模有了简单的概念，我们就可以设计构建系统的约束条件，比如我们可以限制用户在某个时间段内创建和重定向一定数量的URL。</p><p id="bab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要处理数据库(SQL或NoSQL)上的负载。现在让我们转到与规模相关的复杂问题。对于DB秤，我们需要:</p><p id="c3e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr"> a .基于范围的分区:</strong>我们可以根据URL的第一个字母或哈希键，或者根据创建日期或到期日期，将URL存储在单独的分区中。这种方法称为基于范围的分区。</p><p id="e0ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的主要问题是它会导致不平衡的分区。</p><p id="30a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr"> b .基于散列的分区:</strong>在这个方案中，我们获取存储对象的散列。然后，我们根据散列计算使用哪个分区。</p><p id="e0af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的散列函数会将URL随机分配到不同的分区中(例如，我们的散列函数总是可以将任何键映射到[1…256]之间的一个数字)，这个数字将代表我们存储对象的分区。</p><p id="3d10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">清除数据库数据:</strong></p><p id="fdc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">条目应该永远保留还是应该被清除？如果达到用户指定的过期时间，链接会发生什么情况？</p><p id="9b2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们选择主动搜索过期链接来删除它们，这将给我们的数据库带来很大压力。相反，我们可以慢慢地删除过期的链接，做一个懒惰的清理。我们的服务将确保只有过期的链接将被删除，虽然一些过期的链接可以生存更长时间，但永远不会返回给用户。</p><ul class=""><li id="a430" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">每当用户试图访问过期的链接时，我们可以删除该链接并向用户返回一个错误。</li><li id="1eed" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">单独的清理服务可以定期运行，从我们的存储和缓存中删除过期的链接。该服务应该是非常轻量级的，并且可以被调度为仅在用户流量预计较低时运行。</li><li id="5a72" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">我们可以为每个链接设置一个默认的到期时间(例如，两年)。</li><li id="1f42" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">我们是否应该删除在一段时间内没有被访问过的链接，比如说六个月？这可能很棘手。由于存储越来越便宜，我们可以决定永远保留链接。</li></ul><p id="43ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存是频繁访问url的另一个复杂方面。</p><p id="2326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">我们应该有多少缓存？</strong></p><p id="a8c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从20%的日流量开始，根据客户的使用模式，我们可以调整我们需要多少缓存服务器。根据上面的估计，我们需要340 GB的内存来缓存20%的日常流量。</p><p id="eab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jr">哪种缓存回收策略最符合我们的需求？</strong></p><p id="280f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">易失性— ttl、LRU等是多个选项。</p><p id="af1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><p id="8cc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904" rel="noopener ugc nofollow" target="_blank">https://www . educative . io/collection/page/5668639101419520/5649050225344512/5668600916475904</a></p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="377b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能会有更多的缩放问题，我试图涵盖基本的最低要求，同时建立一个可扩展的缩短url服务。</p><p id="371d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有问题吗？建议？评论？</p><p id="1827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是什么？<a class="ae je" rel="noopener" href="/@vaibhav0109"> <strong class="ih jr">在媒体上关注我</strong> </a>成为第一个阅读我的故事的人。</p></div></div>    
</body>
</html>