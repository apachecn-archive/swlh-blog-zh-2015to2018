<html>
<head>
<title>Let’s Write a Chat App in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们用Python写个聊天App吧</h1>
<blockquote>原文：<a href="https://medium.com/swlh/lets-write-a-chat-app-in-python-f6783a9ac170?source=collection_archive---------0-----------------------#2017-11-22">https://medium.com/swlh/lets-write-a-chat-app-in-python-f6783a9ac170?source=collection_archive---------0-----------------------#2017-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不到150行代码中的Tkinter +套接字</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/fbf1546c6d733dde0b5e5a63d1048f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IpquI0xSAap0jeUItwaVg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">It’s Always Good to Have a Conversation!</figcaption></figure><p id="9561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要太频繁，你碰巧创造了一些惊人的简单而有趣的东西，你只是迫不及待地与世界分享。</p><p id="670a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是发生在我身上的事情，事实上，我在这里分享我是如何用非常简洁的Python代码制作一个简单的聊天应用程序的。更何况；我已经在没有<em class="jt">任何</em>第三方依赖的情况下实现了代码！所以让我们开始吧！</p><p id="2223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我创建了一个聊天服务器，通过它可以接收来自想要交流的客户的请求。为此，我使用了好的ole套接字和一点多线程。使用像<a class="ae ju" href="https://twistedmatrix.com/" rel="noopener ugc nofollow" target="_blank"> Twisted </a>和<a class="ae ju" href="https://pymotw.com/3/socketserver/" rel="noopener ugc nofollow" target="_blank"> SocketServer </a>这样的框架是一种选择，但对于我们这样简单的软件来说，这似乎有点大材小用了。</p><h1 id="de98" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">服务器</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/a6e1e4b0e0044b3bfed093c7dc4ce8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1imyonxELroNxrrRV45Aw.jpeg"/></div></div></figure><p id="186d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们如何开始我们的服务器脚本(对于这个应用程序，只有两个脚本:一个用于服务器，另一个用于客户端):</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="1c61" class="kz jw hi kv b fi la lb l lc ld">#!/usr/bin/env python3<br/>"""Server for multithreaded (asynchronous) chat application."""</span><span id="c8a4" class="kz jw hi kv b fi le lb l lc ld">from socket import AF_INET, socket, SOCK_STREAM<br/>from threading import Thread</span></pre><p id="3df4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此我们将使用TCP套接字，因此我们使用<code class="du lf lg lh kv b">AF_INET</code>和<code class="du lf lg lh kv b">SOCK_STREAM</code>标志。我们在UDP套接字上使用它们，因为它们更像是电话，在通信开始之前，接收者必须批准传入的连接，而UDP套接字更像是邮件后的东西(任何人都可以向他/她知道地址的任何接收者发送邮件)，所以在通信发生之前，它们实际上不需要建立连接。显然，TCP比UDP套接字更适合我们目的，因此我们使用它们。这里可以了解更多插座<a class="ae ju" href="https://en.wikipedia.org/wiki/Network_socket" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="137f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入后，我们设置了一些<em class="jt">常量</em>以备后用:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="9e0d" class="kz jw hi kv b fi la lb l lc ld">clients = {}<br/>addresses = {}</span><span id="87ca" class="kz jw hi kv b fi le lb l lc ld">HOST = ''<br/>PORT = 33000<br/>BUFSIZ = 1024<br/>ADDR = (HOST, PORT)<br/>SERVER = socket(AF_INET, SOCK_STREAM)<br/>SERVER.bind(ADDR)</span></pre><p id="df6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将服务任务分为接受新连接、广播消息和处理特定客户。让我们从接受连接开始:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="4725" class="kz jw hi kv b fi la lb l lc ld">def accept_incoming_connections():<br/>    """Sets up handling for incoming clients."""<br/>    while True:<br/>        client, client_address = SERVER.accept()<br/>        print("%s:%s has connected." % client_address)<br/>        client.send(bytes("Greetings from the cave!"+<br/>                          "Now type your name and press enter!", "utf8"))<br/>        addresses[client] = client_address<br/>        Thread(target=handle_client, args=(client,)).start()</span></pre><p id="7249" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是一个永远等待传入连接的循环，一旦获得连接，它就记录连接(打印一些连接细节)并向连接的客户端发送欢迎消息。然后，它将客户端的地址存储在<code class="du lf lg lh kv b">addresses</code>字典中，稍后为该客户端启动处理线程。当然，我们还没有为此定义目标函数<code class="du lf lg lh kv b">handle_client()</code>，但我们会这样做:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="0f42" class="kz jw hi kv b fi la lb l lc ld">def handle_client(client):  # Takes client socket as argument.<br/>    """Handles a single client connection."""<br/>     name = client.recv(BUFSIZ).decode("utf8")<br/>    welcome = 'Welcome %s! If you ever want to quit, type {quit} to exit.' % name<br/>    client.send(bytes(welcome, "utf8"))<br/>    msg = "%s has joined the chat!" % name<br/>    broadcast(bytes(msg, "utf8"))<br/>    clients[client] = name<br/>     while True:<br/>        msg = client.recv(BUFSIZ)<br/>        if msg != bytes("{quit}", "utf8"):<br/>            broadcast(msg, name+": ")<br/>        else:<br/>            client.send(bytes("{quit}", "utf8"))<br/>            client.close()<br/>            del clients[client]<br/>            broadcast(bytes("%s has left the chat." % name, "utf8"))<br/>            break</span></pre><p id="feb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自然地，在我们向新客户发送欢迎消息后，它会回复一个他/她希望用于进一步交流的名字。在<code class="du lf lg lh kv b">handle_client()</code>函数中，我们做的第一件事是保存这个名字，然后向客户端发送另一条消息，关于进一步的指令。接下来是通信的主循环:在这里，我们从客户端接收进一步的消息，如果消息不包含退出指令，我们只需将消息广播给其他连接的客户端(稍后我们将定义广播方法)。如果我们确实遇到了带有退出指令的消息(例如，客户端发送了一个<code class="du lf lg lh kv b">{quit}</code>)，我们将相同的消息回显到客户端(它触发客户端的关闭操作)，然后我们关闭它的连接套接字。然后，我们通过删除客户端的条目来做一些清理工作，最后向其他连接的人大声宣布这个特定的人已经离开了对话。</p><p id="78f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的<code class="du lf lg lh kv b">broadcast()</code>功能来了:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="8c2d" class="kz jw hi kv b fi la lb l lc ld">def broadcast(msg, prefix=""):  # prefix is for name identification.<br/>    """Broadcasts a message to all the clients."""<br/>     for sock in clients:<br/>        sock.send(bytes(prefix, "utf8")+msg)</span></pre><p id="697a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这几乎是不言自明的；它只是将<code class="du lf lg lh kv b">msg</code>发送给所有连接的客户端，并在必要时添加一个可选的<code class="du lf lg lh kv b">prefix</code>。在我们的<code class="du lf lg lh kv b">handle_client()</code>函数中，我们确实传递了一个<code class="du lf lg lh kv b">prefix</code>到<code class="du lf lg lh kv b">broadcast()</code>，我们这样做是为了让人们可以确切地看到谁是特定消息的发送者。</p><p id="d74d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们的服务器所需的所有功能。最后，我们放入一些代码来启动我们的服务器并监听传入的连接:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="a397" class="kz jw hi kv b fi la lb l lc ld">if __name__ == "__main__":<br/>    SERVER.listen(5)  # Listens for 5 connections at max.<br/>    print("Waiting for connection...")<br/>    ACCEPT_THREAD = Thread(target=accept_incoming_connections)<br/>    ACCEPT_THREAD.start()  # Starts the infinite loop.<br/>    ACCEPT_THREAD.join()<br/>    SERVER.close()</span></pre><p id="280b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们<code class="du lf lg lh kv b">join()</code> <code class="du lf lg lh kv b">ACCEPT_THREAD</code>让主脚本等待它完成，而不跳转到下一行，关闭服务器。</p><p id="a0e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了我们的服务器脚本，它呈现在以下要点中(对于那些正在智能手机上阅读本文的人，请访问<a class="ae ju" href="https://github.com/schedutron/CPAP/blob/master/Chap5/chat_serv.py" rel="noopener ugc nofollow" target="_blank"> this </a>链接以获得完整的服务器代码):</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="dee9" class="jv jw hi bd jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks bi translated">客户</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/7bb5a503413b2e6cc989c6d3781e7729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BUJc4gYd9mrVhZkd4hQ6g.jpeg"/></div></div></figure><p id="ac60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这更有趣，因为我们将编写一个GUI！我们使用Tkinter，Python的“包含电池”GUI构建工具来实现我们的目的。让我们先做一些导入:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="beaa" class="kz jw hi kv b fi la lb l lc ld">#!/usr/bin/env python3<br/>"""Script for Tkinter GUI chat client."""</span><span id="f362" class="kz jw hi kv b fi le lb l lc ld">from socket import AF_INET, socket, SOCK_STREAM<br/>from threading import Thread<br/>import tkinter</span></pre><p id="56b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将编写处理消息发送和接收的函数。我们从接收开始:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="f2eb" class="kz jw hi kv b fi la lb l lc ld">def receive():<br/>    """Handles receiving of messages."""<br/>    while True:<br/>        try:<br/>            msg = client_socket.recv(BUFSIZ).decode("utf8")<br/>            msg_list.insert(tkinter.END, msg)<br/>        except OSError:  # Possibly client has left the chat.<br/>            break</span></pre><p id="d548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么又是无限循环？因为我们接收信息的方式是不确定的，与我们发送信息的方式和时间无关。我们不希望这是一个对讲机聊天应用程序，一次只能发送<strong class="ih lx"> <em class="jt">或</em> </strong>接收；我们希望在可能的时候接收信息，在需要的时候发送信息。循环中的功能非常简单；<code class="du lf lg lh kv b">recv()</code>是阻挡部分。它停止执行，直到收到一条消息，当收到消息时，我们继续前进，将消息追加到<code class="du lf lg lh kv b">msg_list</code>。我们将很快定义<code class="du lf lg lh kv b">msg_list</code>，它基本上是一个在屏幕上显示消息列表的Tkinter特性。</p><p id="1013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们定义<code class="du lf lg lh kv b">send()</code>函数:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="3e5a" class="kz jw hi kv b fi la lb l lc ld">def send(event=None):  # event is passed by binders.<br/>    """Handles sending of messages."""<br/>    msg = my_msg.get()<br/>    my_msg.set("")  # Clears input field.<br/>    client_socket.send(bytes(msg, "utf8"))<br/>    if msg == "{quit}":<br/>        client_socket.close()<br/>        top.quit()</span></pre><p id="8859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<code class="du lf lg lh kv b">event</code>作为参数，因为当GUI上的<code class="du lf lg lh kv b">send</code>按钮被按下时，它被Tkinter隐式传递。<code class="du lf lg lh kv b">my_msg</code>是GUI上的输入字段，因此我们使用<code class="du lf lg lh kv b">msg = my_msg.get()</code>提取要发送的消息。之后，我们清除输入字段，然后将消息发送到服务器，正如我们之前看到的，服务器将此消息广播到所有客户端(如果它不是退出消息)。如果是退出消息，我们关闭套接字，然后关闭GUI应用程序(通过<code class="du lf lg lh kv b">top.close()</code>)</p><p id="3f02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还定义了一个函数，当我们选择关闭GUI窗口时，这个函数将被调用。这是一种关闭前清理功能，应该在GUI关闭前关闭套接字连接:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="dd80" class="kz jw hi kv b fi la lb l lc ld">def on_closing(event=None):<br/>    """This function is to be called when the window is closed."""<br/>    my_msg.set("{quit}")<br/>    send()</span></pre><p id="a7a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将输入字段设置为<code class="du lf lg lh kv b">{quit}</code>，然后调用<code class="du lf lg lh kv b">send()</code>，它将按预期工作。现在我们开始构建GUI，在主名称空间中(即，在任何函数之外)。我们首先定义顶级小部件并设置其标题:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="bf0a" class="kz jw hi kv b fi la lb l lc ld">top = tkinter.Tk()<br/>top.title("Chatter")</span></pre><p id="d6f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们创建一个框架来保存消息列表。接下来，我们创建一个字符串变量，主要用于存储我们从输入字段获得的值(我们将很快定义它)。我们将该变量设置为<code class="du lf lg lh kv b">"Type your messages here."</code>来提示用户书写他们的消息。之后，我们创建一个滚动条来滚动这个消息框架。代码如下:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="256f" class="kz jw hi kv b fi la lb l lc ld">messages_frame = tkinter.Frame(top)<br/>my_msg = tkinter.StringVar()  # For the messages to be sent.<br/>my_msg.set("Type your messages here.")<br/>scrollbar = tkinter.Scrollbar(messages_frame)  # To navigate through past messages.</span></pre><p id="82de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们定义将存储在<code class="du lf lg lh kv b">messages_frame</code>中的消息列表，然后将我们到目前为止创建的所有内容打包(在适当的位置):</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="4f76" class="kz jw hi kv b fi la lb l lc ld">msg_list = tkinter.Listbox(messages_frame, height=15, width=50, yscrollcommand=scrollbar.set)<br/>scrollbar.pack(side=tkinter.RIGHT, fill=tkinter.Y)<br/>msg_list.pack(side=tkinter.LEFT, fill=tkinter.BOTH)<br/>msg_list.pack()</span><span id="3e8e" class="kz jw hi kv b fi le lb l lc ld">messages_frame.pack()</span></pre><p id="e41e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们为用户创建输入字段来输入他们的消息，并将其绑定到上面定义的字符串变量。我们还将它绑定到<code class="du lf lg lh kv b">send()</code>函数，这样每当用户按下return时，消息就被发送到服务器。接下来，如果用户希望通过点击发送他们的消息，我们创建发送按钮。同样，我们将这个按钮的点击绑定到<code class="du lf lg lh kv b">send()</code>函数。是的，我们还打包了我们刚刚制作的所有这些东西。此外，不要忘记使用清理功能<code class="du lf lg lh kv b">on_closing()</code>，当用户希望关闭GUI窗口时，应该调用这个功能。我们通过使用<code class="du lf lg lh kv b">top</code>的<code class="du lf lg lh kv b">protocol</code>方法来做到这一点。这是所有这些的代码:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="3026" class="kz jw hi kv b fi la lb l lc ld">entry_field = tkinter.Entry(top, textvariable=my_msg)<br/>entry_field.bind("&lt;Return&gt;", send)<br/>entry_field.pack()<br/>send_button = tkinter.Button(top, text="Send", command=send)<br/>send_button.pack()</span><span id="09b8" class="kz jw hi kv b fi le lb l lc ld">top.protocol("WM_DELETE_WINDOW", on_closing)</span></pre><p id="112f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(几乎)完成了。我们还没有编写连接到服务器的代码。为此，我们必须向用户询问服务器的地址。我已经通过简单地使用<code class="du lf lg lh kv b">input()</code>做到了这一点，所以在GUI开始之前，用户会收到一些命令行提示，要求输入主机地址。这可能有点不方便，您可以为此添加GUI，但是我把它作为家庭作业留给您🙂。这是我的代码:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="ede7" class="kz jw hi kv b fi la lb l lc ld">HOST = input('Enter host: ')<br/>PORT = input('Enter port: ')</span><span id="f3fb" class="kz jw hi kv b fi le lb l lc ld">if not PORT:<br/>    PORT = 33000  # Default value.<br/>else:<br/>    PORT = int(PORT)</span><span id="b8c9" class="kz jw hi kv b fi le lb l lc ld">BUFSIZ = 1024<br/>ADDR = (HOST, PORT)<br/>client_socket = socket(AF_INET, SOCK_STREAM)<br/>client_socket.connect(ADDR)</span></pre><p id="6ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们获得了地址并创建了一个套接字来连接它，我们就启动了接收消息的线程，然后是GUI应用程序的主循环:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="c42c" class="kz jw hi kv b fi la lb l lc ld">receive_thread = Thread(target=receive)<br/>receive_thread.start()<br/>tkinter.mainloop()  # Starts GUI execution.</span></pre><p id="413d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！我们已经编写了聊天应用程序。同样，完整的客户端脚本在下面的要点中给出(对于智能手机上的读者，这里是要点的链接):</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="9d35" class="jv jw hi bd jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks bi translated">演示</h1><p id="c1ed" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">这种在多台电脑上测试的感觉棒极了。当然，您可以在同一台机器上运行服务器和客户机进行测试(在您的客户机上使用<code class="du lf lg lh kv b">127.0.0.1</code>代替<code class="du lf lg lh kv b">HOST</code>，但是看到不同计算机之间的实时通信感觉棒极了。服务器脚本将记录哪些IP地址正在访问它，客户端脚本将生成一个GUI(在询问主机地址后),类似于下面的屏幕截图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/25c6bd1bc169cc28745235c0ba0042e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MihTDwKFQMDHpIUTxf5Rtg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Client GUI</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/c1de89c8457f3290f18e4d70b5a3406f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33q-TKPi8cXBGC3KoAVmfQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Another Client Connected to the Same Server</figcaption></figure><p id="ad5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">老实说，考虑到背后的Python代码行数，GUI看起来不错，但并不出色！我把让它看起来更好(更直观)的任务留给了你，也许可以像脸书的Messenger一样制作一个左右聊天界面。你甚至可以使用像Kivy这样的第三方库来获得更多的美感和跨平台的可移植性，或者一个网络界面——在评论中发表你的想法。最后，谢谢你的耐心，一直读到最后一个字！我赞赏你的耐心🙂。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="bb3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">页（page的缩写）s:关于我的其他项目(有些较小，有些大得多)，请访问<a class="ae ju" href="https://github.com/schedutron" rel="noopener ugc nofollow" target="_blank">我的GitHub简介</a>。</p><p id="303c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我是博客新手，所以建设性的批评不仅需要，而且非常需要！我乐于接受更好的写作风格、技巧和教学方法——欢迎在评论中提出来。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><figure class="je jf jg jh fd ji er es paragraph-image"><a href="http://buymeacoff.ee/schedutron"><div class="er es me"><img src="../Images/1488dbbce2455ca450822fcdde5782b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*lHomguUE0eH9Y7xHHH82hw.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx">Did you like the read? Medium doesn’t offer partner program in my country―so I ask people to buy me coffee instead.</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="kz jw hi bd jx mg mh mi kb mj mk ml kf iq mm mn kj iu mo mp kn iy mq mr kr ms bi translated">这个故事发表在<a class="ae ju" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这里有263，100多人聚集在一起阅读Medium关于创业的主要故事。</h2><h2 id="7945" class="kz jw hi bd jx mg mh mi kb mj mk ml kf iq mm mn kj iu mo mp kn iy mq mr kr ms bi translated">订阅接收<a class="ae ju" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条</a>。</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>