<html>
<head>
<title>Anomaly Detection using Rapidminer and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rapidminer和Python进行异常检测</h1>
<blockquote>原文：<a href="https://medium.com/swlh/anomaly-detection-using-rapidminer-and-python-9a83508460a5?source=collection_archive---------1-----------------------#2018-01-21">https://medium.com/swlh/anomaly-detection-using-rapidminer-and-python-9a83508460a5?source=collection_archive---------1-----------------------#2018-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直觉得异常检测可能是机器学习的一个非常有趣的应用。我能想到几个可以使用这种技术的场景。</p><p id="2f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将描述我用Kaggle的信用卡欺诈检测数据集进行的一些实验。该数据集包含欧洲持卡人在2013年9月两天内的信用卡交易。在总共284，807个例子中，有492个是欺诈。因此，数据集是高度不平衡的，正类(欺诈)仅占所有交易的0.172%。您可以想象任何这样的数据集都将是高度不平衡的，因为预期的欺诈或异常案例仅占总交易的一小部分。</p><p id="2e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我分两部分进行分析。首先，我在Python中对数据集进行了欠采样，保留了所有欺诈案例，并随机选择了一些非欺诈案例，这样在最终数据集中欺诈案例就有了很好的代表性。在第二部分中，我使用Rapidminer开发模型来预测异常情况。Rapidminer是一个基于GUI的机器学习平台，使您能够设计用于构建和评估模型的流程和工作流。你甚至可以在没有编码背景的情况下做到这一点，所以我认为它对于那些想要快速应用这些技术并实现价值而不必通过过度编码来奋斗的管理者来说是一个非常有用的工具。</p><p id="9c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原始数据集本身可以通过下面的链接从Kaggle下载</p><div class="jd je ez fb jf jg"><a href="https://www.kaggle.com/dalpozz/creditcardfraud" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="hj b fi z dy jl ea eb jm ed ef hh bi translated">信用卡欺诈检测</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">标记为欺诈或真实的匿名信用卡交易</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">www.kaggle.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><p id="3678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于是金融数据，数据集中的要素是原始要素的PCA变换。所以你看到的只是没有背景信息的数值，交易是完全匿名的。第一列是从第一次开始的每个事务的时间(以秒为单位),我在分析中丢弃了这一列。然后有28个数字特征以及一个金额特征列，即交易金额。<strong class="ih jw">最后一列是1代表欺诈案例的类别。</strong>这是我们希望模型学习并能够预测新交易的列。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/72a1307659e37cb0f354dcb4ed8d401c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MrJdUh3hsUD49wLqvGIzA.jpeg"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">Dataset preview</figcaption></figure><p id="6588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在这种不平衡数据集中的问题是类列中的1很少。这些是我们希望能够学习和预测的欺诈案例。然而，如果您的模型只是简单地预测所有的0，您仍然会获得非常高的准确率&gt; 99%，因为大多数交易无论如何都不是欺诈，但您将不会检测到任何异常。</p><p id="2bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我没有使用完整的数据集，而是创建了原始数据集的一个子集，将欺诈案例很好地表示为新数据集中案例的总体百分比。这是用Python完成的，如下所述。</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="481b" class="kr ks hi kn b fi kt ku l kv kw"><em class="kx"># load required libraries</em><br/>from numpy import concatenate<br/>from pandas import read_csv<br/>from pandas import DataFrame<br/>from sklearn.preprocessing import MinMaxScaler<br/>import pandas as pd<br/>import numpy as np<br/><br/>num_features = 30 <em class="kx">#Number of features in the dataset</em><br/>label_feature = 'Class' <em class="kx">#The column in dataset that model is being built to predict</em></span></pre><p id="d75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的库是这段代码所必需的</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="c318" class="kr ks hi kn b fi kt ku l kv kw"><em class="kx"># Reading in the dataset which is in .csv format, has column headings and has an index column</em><br/>dataset = read_csv("creditcard2.csv", header = 0, index_col = 0, squeeze = True, usecols = (i for i in range(0, num_features+1)))</span></pre><p id="95be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后是原作。读取Kaggle数据集的csv文件时，第一个包含时间数据的列被视为索引列。该列只包含数据集中第一个事务的时间信息，因此我认为它不是一个可用于预测的有用特性。</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="c454" class="kr ks hi kn b fi kt ku l kv kw">scaler = MinMaxScaler(feature_range=(-1, 1))<br/>dataset['normAmount'] = scaler.fit_transform(dataset['Amount'].reshape(-1, 1))<br/>dataset = dataset.drop(['Amount'],axis=1)</span></pre><p id="1f89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我使用了MinMaxScaler来规范化Amount列，否则与其他列相比，它的值范围会非常不同。在使用数据进行机器学习之前，这是一般的良好做法。保留这个新的规范化金额列，删除原始金额列。</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="fe1c" class="kr ks hi kn b fi kt ku l kv kw"># Move label column to the end of dataset<br/>cols_at_end = [label_feature]<br/>dataset = dataset[[c for c in dataset if c not in cols_at_end] + [c for c in cols_at_end if c in dataset]]</span></pre><p id="4f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我通常使用上面的代码将标签列移动到数据集的末尾，这样便于阅读并在需要时将其分离出来。在这种情况下，它已经在末尾，所以上面的代码没有变化。</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="efed" class="kr ks hi kn b fi kt ku l kv kw"><em class="kx"># Number of datapoints belonging to the minority class</em><br/>number_fraud = len(dataset[dataset.Class == 1])<br/><br/>fraud_indices = np.array(dataset[dataset.Class == 1].index)<br/><br/><em class="kx"># Finding out the indices of the normal class</em><br/>normal_indices = dataset[dataset.Class == 0].index<br/><br/><br/><em class="kx"># Out of the normal indices, randomly select fraud number of occurences</em><br/>random_normal_indices = np.random.choice(normal_indices, number_fraud, replace = False)<br/><br/>random_normal_indices = np.array(random_normal_indices)<br/><br/><em class="kx"># Appending the 2 sets of indices</em><br/>under_sample_indices = np.concatenate([fraud_indices, random_normal_indices])<br/><br/><em class="kx"># Under sample dataset from the selected indices</em><br/>under_sample_data = dataset.loc[under_sample_indices,:]</span></pre><p id="c3bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码获取原始数据集中欺诈案例的数量，然后随机选择相同数量的非欺诈案例来构建一个50:50的欠采样数据集。如果你仔细观察，上面的代码有一个错误。这与……有关。loc操作数，它不完全执行我们想要的，我无法解决这个问题。但我仍然得到了一个欠采样数据集，其中有近28%的欺诈案件，所以我继续前进。也许在未来的某个时刻，我可以解决这个错误。</p><pre class="jy jz ka kb fd km kn ko kp aw kq bi"><span id="e198" class="kr ks hi kn b fi kt ku l kv kw">under_sample_data.to_csv('Undersampled.csv', encoding='utf-8', index=False)</span></pre><p id="12aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将欠采样数据集导出为. csv文件，该文件将在Rapidminer中用于剩余的分析。所以从现在开始，我们在Rapidminer工作室工作。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ky"><img src="../Images/d1be7b1ad70ecb8dcb35eb9bf1dc51c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h71U2zF9V7_f-xTeoy8HuA.jpeg"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">Rapidminer Process Flow</figcaption></figure><p id="73bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面显示了在Rapidminer中实现的过程。使用Rapidminer界面，很容易看到和理解正在发生的事情。上面使用的操作符是拖放操作，因此非常容易实现。我们通过洗牌对欠采样数据集进行80:20分割，并使用其多个副本来训练多个预测器。将每个学习模型应用于20%验证分割，并获得结果。我还使用了可视化操作的自组织映射(SOM)来实际可视化学习到的模型。</p><p id="2f94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我比较了4种技术:逻辑回归，这是这种二项式分类任务的默认选择，神经网络，决策树和支持向量机。该过程运行不到一分钟，结果如下:</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/91af3893a72066ff0816f8b840ab4763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKaxu6jAWyuYTViUsw-8zw.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/b294dfa367da4dc8fa2cd063ce1a52b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfNsJsx3bccykC-OHtbEJw.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/98f89ecefb0b31c016aed4392d93b687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcFpV4SNyHkKSV2eogoZSg.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/9037346cdc80738e4e14c8195b7573aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ojj029m3HNiYBJKn6SvcCg.jpeg"/></div></div></figure><p id="cd1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果可以看出，每个模型都做了很好的预测。准确度相当不错。逻辑回归是最好的表现。所以建立一个异常检测系统真的很简单！一些欺诈案例被遗漏，可能需要进一步微调。</p><p id="222d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可视化算子的自组织映射通过将学习到的模型缩减到二维空间来帮助可视化它们。下面显示了四个可视化的摘要，每个点代表预测的类。可以清楚地观察到边界，显示所学的分类。你也可以观察到亮橙色或浅蓝色的点，这是少数错误预测的情况。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es la"><img src="../Images/a503af6f587b380090bede161ea38356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHuubhpO8XYlBcXGhr7Giw.jpeg"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">SOM visualizations</figcaption></figure><p id="332a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，还有最后一步要完成，那就是使用整个数据集，应用学习到的模型，并观察它对完整数据的表现。该过程类似于上面显示的Rapidminer过程，只是您使用的是原始数据集，而不是20%分割数据副本。工作室版本只能处理10，000个数据点，但应该足够了。获得的结果如下。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/e32b21c42f67b389d25024083b73b3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVKIMbSbfp382J0gyoMDVQ.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/87db90c5672111b55a4d3287163c1506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDpi7UcB7174DJ4tbX17Kw.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/e8f2bfa14dbbea1e534f821e936c5c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gMmlMQeNEBfYpNFK_mYfw.jpeg"/></div></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kz"><img src="../Images/76bd326fcf29b73a4bab61bad15b3d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zq-VxiCvyOYfBNVFLZ9IUQ.jpeg"/></div></div></figure><p id="e7d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以看出，虽然逻辑回归和神经网络模型捕获所有欺诈案件，但是它们也预测假阳性，这可能导致大量非欺诈案件的调查。虽然决策树和SVM模型做出的假阳性预测要少得多，但它们也确实遗漏了一个实际的欺诈案例。人们必须根据这些结果决定使用哪种模型。也许可以根据交易金额进行调查，或者可以使用一组模型进行预测。</p><p id="1686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种技术可以应用于其他领域—保险的异常应用、异常清单填写等。真正的困难在于捕获正确的数据，这些数据可以作为用于训练的数据集的一部分，这就是需要规划和创造力的地方。</p><p id="5522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章是一个有趣的阅读！</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lb"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="kr ks hi bd lc ld le lf lg lh li lj lk iq ll lm ln iu lo lp lq iy lr ls lt lu bi translated">这个故事发表在<a class="ae lv" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，有295，232+人关注。</h2><h2 id="7945" class="kr ks hi bd lc ld le lf lg lh li lj lk iq ll lm ln iu lo lp lq iy lr ls lt lu bi translated">订阅接收<a class="ae lv" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条</a>。</h2><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lb"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>