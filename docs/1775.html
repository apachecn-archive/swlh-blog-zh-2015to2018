<html>
<head>
<title>Maintaining your Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">维护您的数据库</h1>
<blockquote>原文：<a href="https://medium.com/swlh/maintaining-your-database-b9911167112f?source=collection_archive---------4-----------------------#2018-01-02">https://medium.com/swlh/maintaining-your-database-b9911167112f?source=collection_archive---------4-----------------------#2018-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d630" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">维护PostgreSQL的快速指南</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d8ff28d5b5c72d2a84f2ade96bcee806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsAVaCGNFk62JmIGjCjmOw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">by pexels.com</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="a802" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在过去的两年里，我一直在使用PostgreSQL。它已经成为我的首选数据库，因为我可以对大型数据集执行查询。我还可以将它用作时间序列数据库，当然也是关系数据库的经典用法；实体间关系高度耦合的物流仓库。</p><p id="e6d1" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我想和大家分享一下我最近在使用PostgreSQL时遇到的一个问题，以及我是如何修复的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/11c073285043a27fe6d7685d0e0154d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*w0ERnJ2_GpalVXmB4gQWEw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">If you familiar with vacuum great! if not keep reading `vacuum analyze verbose my_table`</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3d8d" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">如果您已经使用PostgreSQL，那么您已经知道它是一个非常好的数据库。有了最新版本的PostgreSQL，2017年11月发布了10.1版本，二进制JSON的支持(现在看来还是有很多postgres用户没有在用这个功能)几乎所有用例都能解决。</p><p id="9e01" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">使用PostgreSQL，如何管理数据库以及如何设计模式比使用什么类型的数据库更重要。如果您的表模式设计得很好，那么在迁移表时，您将最终节省时间，此外，您的数据库将执行得更好。</p><blockquote class="kz la lb"><p id="b8f1" class="ka kb lc kc b kd ke kf kg kh ki kj kk ld km kn ko le kq kr ks lf ku kv kw kx hb bi translated">您也可以简单地通过不使用主键和外键来设计高内聚和低耦合的数据库，并将其视为NoSQL数据库。</p></blockquote></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="7c61" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated"><strong class="kc lg">用例:</strong> <br/>我无法分享我遇到的确切用例。相反，我将描述一个具有相似参数的不同场景。</p><p id="b164" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我有100万用户，我需要在整整一周内每10分钟跟踪一次每个用户的位置。我最终需要提供一份过去一周内<em class="lc">所有</em>的位置报告，以及他们在任何给定时间的当前位置。这意味着我的数据库中每天应该有1.44亿条记录(100万人，每10分钟一次他们的位置)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/069e820b485d17e3567ba99bf487971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/1*lq7AYEOnLROI7TNoMC7jWg.gif"/></div><figcaption class="jp jq et er es jr js bd b be z dx">1M people, data sample every 10 minutes get us to 144M records per day</figcaption></figure><p id="de06" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我每天运行一个cron作业，删除超过一周的所有记录。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="4f14" class="ln ig hi lj b fi lo lp l lq lr">// TODAY = 2018-01-01T00:00:00.000+00:00<br/>DELETE FROM MY_TABLE WHERE created_at &lt;= '2017-12-25T00:00:00.000+00:00'</span></pre><p id="0311" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">到目前为止一切顺利，对吧？我不断地将数据插入到我的数据库中，并且每天一次通过删除来清除“旧”数据。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="966a" class="if ig hi bd ih ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc bi translated"><strong class="ak">问题</strong></h1><p id="1aa8" class="pw-post-body-paragraph ka kb hi kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx hb bi translated">在最初的几个月里，数据库运行良好。但是，随着时间的推移，我开始发现它的性能存在一些问题。这令人惊讶，因为总记录数保持不变；这意味着在任何给定的时间都有一周的数据(多给或少给一天)。</p><p id="732e" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我检查的第一件事是查看cron作业是否正在运行，但它运行正常。然后我检查了相同记录的数量。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="5b67" class="ln ig hi lj b fi lo lp l lq lr">select count(*) from MY_TABLE; //same number of records wtf?!</span></pre><p id="a16d" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我使用<em class="lc"> psql </em>来执行查询，当运行<em class="lc"> \dt+ </em>时，我注意到表的大小变大了，尽管我每天都在删除旧记录！！！</p><p id="cbd7" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我接下来做的事情是检查我是否能在我的数据库中找到旧记录，但是它们不见了，奇怪。我意识到我别无选择，只能更深入地研究PostgreSQL文件系统，检查这些文件是否包含一些应该删除的旧数据。我打开十六进制编辑器，开始寻找数据。但是，一定有更简单的方法来检查PostgrSQL中的原始数据。然后…我找到了！pageinspect模块为我提供了一些额外的功能来检查我的原始数据。</p><blockquote class="kz la lb"><p id="8f0c" class="ka kb lc kc b kd ke kf kg kh ki kj kk ld km kn ko le kq kr ks lf ku kv kw kx hb bi translated"><code class="du mc md me lj b">pageinspect</code>模块提供的功能允许您在较低的级别检查数据库页面的内容，这对于调试非常有用。所有这些功能只能由超级用户使用。—postgresql.org</p></blockquote><p id="02b0" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在使用<code class="du mc md me lj b">pageinspect</code>模块时，我使用了<code class="du mc md me lj b">heap_page_items</code>函数，这对于查看堆页面上的所有行指针非常有用。显示所有元组，无论在复制原始页时元组对于MVCC快照是否可见。在我的情况下，这是被删除的内容。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="e937" class="ln ig hi lj b fi lo lp l lq lr">SELECT lp, lp_len, t_xmin, t_xmax, lp_off from heap_page_items(get_raw_page('MY_TABLE', 0));</span></pre><blockquote class="kz la lb"><p id="aa30" class="ka kb lc kc b kd ke kf kg kh ki kj kk ld km kn ko le kq kr ks lf ku kv kw kx hb bi translated">当运行<code class="du mc md me lj b">heap_page_items</code>时，你会注意到列名以<code class="du mc md me lj b">t_ </code>和<code class="du mc md me lj b">lp_</code>开始，这是因为它将引用元组和行指针。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/aef4ea1dfe41094f319965ca9b287e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C9DJ05p6owU6ILeYHcP6A.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Heap tuple header data</figcaption></figure><p id="4d50" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated"><code class="du mc md me lj b">pageinspect</code>模块中的另一个函数是<code class="du mc md me lj b">page_header</code>，它可以显示所有PostgreSQL堆和索引页共有的字段。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="9e43" class="ln ig hi lj b fi lo lp l lq lr">SELECT * FROM page_header(get_raw_page('MY_TABLE', 0));<br/>    lsn    | checksum | flags  | lower | upper | special | pagesize | version | prune_xid<br/>-----------+----------+--------+-------+-------+---------+----------+---------+-----------<br/> 0/24A1B50 |        0 |      1 |   232 |   368 |    8192 |     8192 |       4 |         0<strong class="lj lg">Hello MVCC (also known as MCC)</strong></span></pre><p id="f137" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">到目前为止，我意识到使用delete语句删除记录并没有从数据库中清除空间。我需要挖掘PostgreSQL的源代码，以便了解我的数据库内部发生了什么。</p><p id="bd09" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在试图找出像<code class="du mc md me lj b">t_xmin</code>和<code class="du mc md me lj b">t_xmax</code>这样的列时，我意识到PostgreSQL的实现是一行有不止一个副本，这些行将有不同的<code class="du mc md me lj b">t_xmin</code>和<code class="du mc md me lj b">t_xmax</code>值，这解释了为什么我的数据库在使用<code class="du mc md me lj b">count</code>方法(<code class="du mc md me lj b">SELECT count(*) FROM MY_TABLE</code>)时尽管行数保持不变，但大小却在增长。</p><p id="1062" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated"><code class="du mc md me lj b">t_xmin</code>和<code class="du mc md me lj b">t_xmax</code>是MVCC的PostgreSQL实现的一部分，其中<code class="du mc md me lj b">xmin</code>列记录创建行的事务id，而<code class="du mc md me lj b">xmax</code>记录通过更新或删除使行过期的事务id。</p><h1 id="9212" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">等什么？MVCC？</strong></h1><blockquote class="mg"><p id="f775" class="mh mi hi hj mj mk ml mm mn mo mp kx dx translated">多版本并发控制(MCC或MVCC)是一种并发控制方法，通常由数据库管理系统使用，以提供对数据库的并发访问，并在编程语言中实现事务存储器。[1]—<a class="ae mq" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" rel="noopener ugc nofollow" target="_blank">wikipedia.org</a></p></blockquote><p id="767f" class="pw-post-body-paragraph ka kb hi kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx hb bi translated">我意识到PostgreSQL保存了一行的多个副本。这很有意义，因为我们希望即使在数据库执行写操作时也能够从一行中读取数据。</p><p id="2701" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">PostgreSQL如何找到行的当前版本？那就是<code class="du mc md me lj b">t_ctid.<br/></code>过去，当没有为一行使用唯一标识符时，我使用<code class="du mc md me lj b">ctid</code>删除重复的记录。</p><blockquote class="kz la lb"><p id="4aaa" class="ka kb lc kc b kd ke kf kg kh ki kj kk ld km kn ko le kq kr ks lf ku kv kw kx hb bi translated"><code class="du mc md me lj b">t_ctid</code>是指向行的指针，PostgreSQL中的每一行都有一个指向当前行的<code class="du mc md me lj b">ctid</code>。</p></blockquote><p id="723e" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">总结一下这个问题，我每天插入1.44亿条记录，但它们从未从我的数据库中完全删除，这是因为配置没有触发负责从文件中移除指针和删除记录的<code class="du mc md me lj b">VACUUM</code>进程。</p><h1 id="8923" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决办法</h1><p id="53b0" class="pw-post-body-paragraph ka kb hi kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx hb bi translated">像任何其他bug或问题一样，我们作为程序员面临的90%的问题是理解问题。我将把我的解决方案分成两部分，</p><ul class=""><li id="1a64" class="mw mx hi kc b kd ke kh ki kl my kp mz kt na kx nb nc nd ne bi translated"><strong class="kc lg">确保每周运行</strong> <code class="du mc md me lj b"><strong class="kc lg">VACUUM FULL</strong></code> <strong class="kc lg">。<br/> </strong>我应该在运行完<code class="du mc md me lj b">DELETE</code>查询后运行一个真空。<br/>T7】</li><li id="4959" class="mw mx hi kc b kd nf kh ng kl nh kp ni kt nj kx nb nc nd ne bi translated"><strong class="kc lg">删除重复值</strong>(如果用户位置没有变化，我们为什么要每10分钟存储一次用户位置)。<br/>使用<code class="du mc md me lj b">ctid<br/></code>删除重复值，方法是将表格与自身进行比较，并确保仅保留一个<code class="du mc md me lj b">ctid</code>(唯一记录)，同时仅删除同一用户在同一位置的记录。(我也可以使用记录的创建日期<code class="du mc md me lj b">created_at</code>，以确保删除4小时内的记录<code class="du mc md me lj b">WHERE x.created_at &lt; (y.created_at + 4 hours)</code>)。</li></ul><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="6963" class="ln ig hi lj b fi lo lp l lq lr">DELETE FROM MY_TABLE x USING MY_TABLE y <br/>WHERE x.ctid &lt; y.ctid and <br/>x.user_id = y.user_id and <br/>x.latitude = y.latitude and <br/>x.logitude = y.logitude<br/>x.created_at - y.created_at &lt; 4 HOURS;</span></pre><h1 id="3ada" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">自动驾驶解决方案</h1><p id="0dba" class="pw-post-body-paragraph ka kb hi kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx hb bi translated">从表中删除行不会从我的表中清除空间，我需要确保我的表被清空，并通过适当的配置频繁地进行分析。我也可以通过设置<code class="du mc md me lj b">autovacuum</code>来改变我的表格。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="bf2e" class="ln ig hi lj b fi lo lp l lq lr">/*<br/>Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table.<br/>*/<br/>ALTER TABLE MY_TABLE SET (autovacuum_analyze_threshold = 100);</span><span id="2e5f" class="ln ig hi lj b fi nk lp l lq lr">/* <br/>Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.1 (10% of table size). <br/>*/ <br/>ALTER TABLE MY_TABLE SET (autovacuum_analyze_scale_factor = 0);</span><span id="20c2" class="ln ig hi lj b fi nk lp l lq lr">/*<br/>Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.<br/>*/<br/>ALTER TABLE MY_TABLE SET (autovacuum_vacuum_threshold = 100);</span><span id="7bde" class="ln ig hi lj b fi nk lp l lq lr">/*<br/>Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).<br/>*/<br/>ALTER TABLE MY_TABLE SET (autovacuum_vacuum_scale_factor = 0.2);</span></pre><p id="7dcc" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">手动运行的方式将是:</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="97bf" class="ln ig hi lj b fi lo lp l lq lr">VACUUM ANALYZE MY_TABLE;</span></pre><p id="e50c" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我喜欢仔细检查每一件事，确保程序按照我设置的那样运行。为了检查<code class="du mc md me lj b">vacuum</code>流程是否正常运行，我使用了如下查询:</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="a9e7" class="ln ig hi lj b fi lo lp l lq lr">SELECT relname, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze<br/>FROM pg_stat_all_tables<br/>WHERE schemaname = 'public' AND <br/>relname = 'MY_TABLE';</span></pre><h1 id="66b9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="1e4d" class="pw-post-body-paragraph ka kb hi kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx hb bi translated">我认为PostgreSQL是一个了不起的数据库。但是像其他工具一样，你需要知道如何使用它。在创建模式之前，需要进行大量的规划。但更重要的是理解你的数据；<br/>你的数据会有多大，你想用你的数据解决什么问题。</p><p id="fa05" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">我希望这篇文章能帮助你了解如何维护你的PostgreSQL。请在推特上关注我。如果你有任何问题，我很乐意回答。</p><h1 id="b9f5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">学分和参考</h1><p id="a9e8" class="pw-post-body-paragraph ka kb hi kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx hb bi translated">Postgres文档—<a class="ae mq" href="https://www.postgresql.org/docs/9.5/static/sql-vacuum.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.5/static/sql-vacuum.html</a></p><p id="fae0" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">github上的Postgresql源代码—<a class="ae mq" href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/htup.h;h=0e626e8469cd67973cfaccc38d3af511eed30ea2;hb=HEAD#l70" rel="noopener ugc nofollow" target="_blank">https://git.postgresql.org/gitweb/?p = postgresql.gita = blobf = src/include/access/htup . h；h = 0 e 626 e 8469 CD 67973 faccc 38d 3 af 511 eed 30 ea 2；hb=HEAD#l70 </a></p><div class="nl nm ez fb nn no"><a href="https://github.com/postgres/postgres/blob/be72b9c378bfe99a3d175c98d36dc150229f4faf/src/backend/postmaster/autovacuum.c" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="hj b fi z dy nt ea eb nu ed ef hh bi translated">postgres/postgres</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">官方PostgreSQL GIT存储库的镜像。请注意，这只是一个“镜像”——我们不能使用“拉”……</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jn no"/></div></div></a></div><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es od"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="ln ig hi bd ih oe of og il oh oi oj ip kl ok ol it kp om on ix kt oo op jb oq bi translated">这个故事发表在<a class="ae mq" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的企业家出版物，拥有292，582+人。</h2><h2 id="7945" class="ln ig hi bd ih oe of og il oh oi oj ip kl ok ol it kp om on ix kt oo op jb oq bi translated">在这里订阅接收<a class="ae mq" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es od"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>