<html>
<head>
<title>React Context-Api and Lazy-loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应上下文Api和延迟加载</h1>
<blockquote>原文：<a href="https://medium.com/swlh/react-context-api-and-lazy-loading-4c4b0a48f696?source=collection_archive---------1-----------------------#2018-12-26">https://medium.com/swlh/react-context-api-and-lazy-loading-4c4b0a48f696?source=collection_archive---------1-----------------------#2018-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/7146dc0477fa560ffe8129814a08cf40.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*x01TFFrUCRYHikoWXwT14g.png"/></div><figcaption class="hn ho et er es hp hq bd b be z dx">React</figcaption></figure><div class=""/><h1 id="a306" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么…</h1><p id="1c86" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我正在做一个新的电子商务网站，我想分享一些我在这个项目中学到并使用的东西。首先，关于这篇文章的两个主题，有大量的文献和讨论。然而，我将演示如何使用React的上下文api和代码分割(也称为延迟加载)来创建一个模型，我稍后将充实该模型以服务于更高的目的。这个博客提醒我自己我学到了什么，也是如何让这两件事发挥作用的指南。</p><h1 id="0ba2" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么…</h1><p id="8dac" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我想用React最新最棒的<em class="km">按需加载代码。我喜欢这个库提供的开箱即用、易于使用的工具。我是一个相当新的懒人加载，因为它是在我工作的时候介绍给我的。我知道很多人不喜欢Angular 7或之前的六种Angular风格，也不喜欢AngularJS，但我会让它工作，😏。也就是说，在那里学习它让我想在React中尝试一下，因为我立即看到了它的好处。</em></p><p id="9ef5" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">也就是说，我们将继续用一种方法来解决这个问题。对于读者来说，我先写代码，然后展示它。</p><h1 id="933b" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">准备</strong>进行:</h1><p id="7d5d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先来看看我的<code class="du kt ku kv kw b">app.js</code>。我为我的组件使用了<a class="kx ky ge" href="https://medium.com/u/9d99f1b2974b?source=post_page-----4c4b0a48f696--------------------------------" rel="noopener" target="_blank"> Material-UI </a>来帮助启动项目。这个文件是基本的，用一个<code class="du kt ku kv kw b">&lt;Button /&gt;</code>渲染一个<code class="du kt ku kv kw b">&lt;Grid /&gt;</code>。我想要的是，当这个按钮被点击时，包含表单的模态应该被呈现到屏幕上。</p><p id="3d6b" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这就是延迟加载的用武之地。当延迟加载时，我们希望我们没有使用的代码，或者用户第一次加载应用程序时不需要的代码在他们需要的时候加载。在这种情况下，我们希望在单击按钮时加载另一个组件。</p><p id="dc9a" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">目前还没有，但我们会实现的。</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c45b" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">接下来，让我们来看看我们的<code class="du kt ku kv kw b">form.js</code>。这个代码是当我们的按钮被点击时我们想要延迟加载的代码。它是我们库的一个组件集合，用来创建一个模型。</p><p id="1a46" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们稍后将修改它，这样它将没有状态对象，而是它的状态将取自<code class="du kt ku kv kw b">Context</code>，这是一个帮助我们从一个组件到另一个组件获取信息的伟大工具。这是用来替代Redux或者传道具的。在这种情况下，我们可以传递道具，但这将意味着<strong class="jq kn">而不是</strong>利用<em class="km">新的</em> <code class="du kt ku kv kw b">Context-Api</code>。</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="8072" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">现在我们有了一个起点，让我们开始修改这段代码，这样我们就可以使用延迟加载了。我们应该做的第一件事是更新我们的<code class="du kt ku kv kw b">&lt;App /&gt;</code>中的<code class="du kt ku kv kw b">&lt;Button /&gt;</code>,这样当点击时它将显示表单。我们将通过<em class="km">惰性地导入它来做到这一点——</em>参考下面的片段。<code class="du kt ku kv kw b">line 1</code>拥有我们需要延迟加载的重要代码。它使用React的<code class="du kt ku kv kw b">lazy()</code>方法和动态的<code class="du kt ku kv kw b">import()</code>方法来完成这个任务。</p><p id="c581" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们在<code class="du kt ku kv kw b">line 8</code>上添加了一个<code class="du kt ku kv kw b">handleClick()</code>方法来触发事件加载并打开我们的对话框。</p><p id="bb6d" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">在<code class="du kt ku kv kw b">line 27</code>上，我们将使用短路来帮助我们渲染<code class="du kt ku kv kw b">&lt;Form /&gt;</code>组件。这里有更多关于短路<a class="ae lf" href="https://codeburst.io/javascript-short-circuit-conditionals-bbc13ac3e9eb" rel="noopener" target="_blank">的内容</a>。我们还需要将惰性加载的<code class="du kt ku kv kw b">&lt;Form /&gt;</code>包装在一个<code class="du kt ku kv kw b">&lt;Suspense /&gt;</code>组件中，并向<code class="du kt ku kv kw b">&lt;Suspense /&gt;</code>传递一个<code class="du kt ku kv kw b">fallback</code>道具。<code class="du kt ku kv kw b">fallback</code>是当我们的<code class="du kt ku kv kw b">&lt;Form /&gt;</code>组件加载时将向我们的用户显示的内容。</p><p id="f8f3" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">现在有些人会注意到我们可以就此打住——我在文章的前面提到过。如果我们想单独延迟加载组件，并将属性<code class="du kt ku kv kw b">open</code>传递给<code class="du kt ku kv kw b">&lt;Form /&gt;</code>，这将是一个布尔值，而属性<code class="du kt ku kv kw b">toggleOpen</code>将是一个函数，我们可以这样做，而不必担心<code class="du kt ku kv kw b">Context</code>。你也会取得同样的成就。</p><p id="bb72" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们仍将继续…</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="554d" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们还需要修改我们的<code class="du kt ku kv kw b">lazy-load-context-form.js</code>文件，使其自动设置为打开<code class="du kt ku kv kw b">true</code>。这只是为了测试我们的惰性负载的功能，以后会被替换。这种变化看起来像这样:</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="b10c" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">现在，我们可以开始偷懒了。我们可以通过查看我们的开发工具<em class="km">网络</em>标签来测试我们的组件延迟加载表单。我们应该看到，当应用程序最初加载时，我们将有一个已经加载的<code class="du kt ku kv kw b">2.chunk.js</code>文件。点击我们的按钮后。我们将看到两个新的块文件添加到我们的历史中。</p><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/4db0e3ac65109d17a0e02dd1696c21b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EgNeY8Ir5J0ZJwnf3KrXHQ.gif"/></div></div></figure><h1 id="7634" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">上下文……</strong></h1><p id="870b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">既然我们是懒惰的加载大师，让我们通过添加<code class="du kt ku kv kw b">Context</code>来控制对话框的打开和关闭部分。首先，我们需要创建一个上下文对象。我创建了另一个文件来做这件事，但是我们真正需要的是在我们的<code class="du kt ku kv kw b">React</code>实例上调用<code class="du kt ku kv kw b">createContext()</code>方法，并把它存储在一个我们将导出的变量中，这样我们就可以在需要的地方导入它。明白了！？</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="bb3f" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">酷！现在有趣的部分来了！</p><p id="a839" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们现在必须为我们的<code class="du kt ku kv kw b">FormContext</code>添加一个<code class="du kt ku kv kw b">Provider</code>和<code class="du kt ku kv kw b">Consumer</code>到我们的应用程序中。首先，我们将跳回我们的<code class="du kt ku kv kw b">&lt;App /&gt;</code>并导入我们新创建的<code class="du kt ku kv kw b">FormContext</code>。参见下面的<code class="du kt ku kv kw b">line 1</code>。接下来，我们将把我们的<code class="du kt ku kv kw b">&lt;Button /&gt;</code>包装在一个<code class="du kt ku kv kw b">&lt;FormContext.Provider /&gt;</code>中，并传递给它一个<code class="du kt ku kv kw b">value</code>道具。这个道具将是我们的消费者可以访问的状态。换句话说，我们放在这里的内容可以并且将会在我们导入<code class="du kt ku kv kw b">FormContext</code>的应用程序的其他地方共享。我们传递两个东西:一个布尔值和一个函数。参见下面的<code class="du kt ku kv kw b">line 28</code>至<code class="du kt ku kv kw b">line 31</code>。我们对<code class="du kt ku kv kw b">&lt;App /&gt;</code>的改进现在允许我们远程控制表单的行为。它现在保持状态，并提供一个函数来控制表单所需的open属性是<code class="du kt ku kv kw b">true</code>还是<code class="du kt ku kv kw b">false</code>。这些变化看起来会是这样的:</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="d57e" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们快完成了！最后，我们需要在<code class="du kt ku kv kw b">lazy-load-context-form.js</code>中使用提供的上下文。首先我们导入我们的<code class="du kt ku kv kw b">FormContext</code>。我们还移除了这个组件的原始<code class="du kt ku kv kw b">state</code>及其所有方法。我们在这里不再需要它们，因为我们正在从我们的<code class="du kt ku kv kw b">&lt;App /&gt;</code>组件远程控制一切。然后，我们将我们的<code class="du kt ku kv kw b">&lt;Dialog /&gt;</code>组件包装在一个<code class="du kt ku kv kw b">&lt;FormContext.Consumer /&gt;</code>中，并使用匿名函数返回我们的模态。你会看到这个函数将一个<code class="du kt ku kv kw b">Object</code>作为参数，我们正在<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>它，这样我们就可以通过它们的变量名来访问它的属性。这是我们在<code class="du kt ku kv kw b">&lt;App /&gt;</code>中的提供程序中创建的同一个对象。我们现在将这些变量用于我们的<code class="du kt ku kv kw b">&lt;Dialog /&gt;</code>和<code class="du kt ku kv kw b">&lt;Button /&gt;</code>组件中的<code class="du kt ku kv kw b">open</code>、<code class="du kt ku kv kw b">onClose</code>和<code class="du kt ku kv kw b">onClick</code>道具。</p><figure class="kz la lb lc fd hk"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="4292" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">就是这样！我冒昧地在我们的匿名函数中添加了一个<code class="du kt ku kv kw b">console.log(open)</code>,尽管我没有在上面的代码片段中包含它，这样我们就可以确保我们得到了适当的上下文。见下图gif求证。</p><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ll"><img src="../Images/eb9694ac80a881724a8e1ed27197ac98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5vwwKNEOrlii7QQLyrpsWQ.gif"/></div></div></figure><p id="ab4f" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这就是所有的人！我希望你喜欢这个博客。请留下评论/建议。感谢阅读！</p><p id="9804" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">更多关于延迟加载的信息请点击。</p><p id="398a" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">github上的项目链接<a class="ae lf" href="https://github.com/JNaeemGitonga/lazy-load-context" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>