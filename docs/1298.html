<html>
<head>
<title>Angular: Unit Testing Jasmine, Karma (step by step)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:单元测试Jasmine，Karma(循序渐进)</h1>
<blockquote>原文：<a href="https://medium.com/swlh/angular-unit-testing-jasmine-karma-step-by-step-e3376d110ab4#2017-11-30">https://medium.com/swlh/angular-unit-testing-jasmine-karma-step-by-step-e3376d110ab4#2017-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c7c028d7481b926781b4cc2928f3a916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKbZZOcx2IfRAe4bYF_eeQ.png"/></div></div></figure><p id="de1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何至少试图严肃对待的项目中使用单元测试是必须的，不管你是否选择使用TDD(测试驱动开发)方法，使用它都会有很多好处。</p><p id="f941" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将首先简要介绍单元测试的好处，然后我们将使用jasmine和karma创建一个完整的角度单元测试示例，解释过程的每一步。</p><h2 id="c4e7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">单元测试的好处</h2><p id="12f6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们先来看看我认为在你的解决方案中使用单元测试的主要原因…</p><ul class=""><li id="dea9" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated"><strong class="is kx">改进实现的设计。</strong> <br/>在开发人员中，不经过深思熟虑就开始编写一个特性是非常常见的错误。使用单元测试会迫使你思考和重新思考设计，如果你使用TDD，影响会更大。</li><li id="6ceb" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is kx">允许重构。</strong> <br/>既然你已经有了确保一切按预期运行的测试，你可以很容易地对代码进行修改，并确信你没有添加任何错误。</li><li id="60e3" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">在不破坏任何东西的情况下添加新功能。当你添加一个新特性时，你可以运行测试来确保你没有破坏应用程序的任何其他部分。</li></ul><p id="4205" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有很多，但这三个已经是任何项目中的一个巨大胜利，对我来说是交易的达成者。但是如果你还不相信，让我们再提几个。</p><ul class=""><li id="2af1" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">测试是很好的文档。</li><li id="1b18" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">测试让开发人员对他们的工作更有信心。</li></ul><blockquote class="ld le lf"><p id="2978" class="iq ir lg is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated">你可以说他们所有的好处都是以极大的代价换来的:时间，但这是完全错误的。当你引入新的特性或者进行任何重构的时候，使用单元测试所花费的时间与它们为你节省的时间相比是很少的。花费在解决bug上的时间将会比不使用单元测试时大大减少。</p></blockquote><p id="9178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们找点乐子……我们将使用Angular、Jasmine和Karma创建一个小而完整的应用程序示例。</p><p id="f11e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是我们将要谈论的一些事情:</p><ul class=""><li id="dc94" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">解释一下工具karma和jasmine。</li><li id="a449" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">解释一下karma配置。</li><li id="6092" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">解释测试条目文件。</li><li id="3ae9" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">创建第一个简单的测试。介绍jasmine和角度测试功能。</li><li id="c408" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">测试角形。介绍jasmine和角度测试功能。</li><li id="a454" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">用服务测试组件。介绍角度测试功能。</li></ul><h2 id="dc46" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">用茉莉和业力创造一个有棱角的项目</h2><p id="1a0d" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">正如angular团队建议的那样，我们将使用<a class="ae lk" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> angular-cli </a>来创建我们的应用程序。通过这样做，茉莉和业力的结构就为我们解决了。</p><p id="88a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装angular-cli并创建一个新项目:</p><ol class=""><li id="6bfe" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn ll ku kv kw bi translated">npm安装-g @angular/cli</li><li id="f97d" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn ll ku kv kw bi translated">ng新角度单位测试</li></ol><p id="9fa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您创建项目时，所有的依赖项都被安装在其中，这是您创建测试所需要的一切。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/c8b68810c11ca8af51343f0a2c546303.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*mSGcvJ7zksygPY3Czn_6QA.png"/></div></figure><p id="b702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，您可以看到为测试目的而安装的所有依赖项。让我们来看看更重要的。</p><ul class=""><li id="3108" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated"><strong class="is kx">茉莉花芯。</strong> <a class="ae lk" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>是我们将要用来创建测试的框架。它有很多功能，允许我们编写不同类型的测试。</li><li id="0027" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is kx">因果报应。</strong> <a class="ae lk" href="https://karma-runner.github.io/1.0/index.html" rel="noopener ugc nofollow" target="_blank"> Karma </a>是我们测试的任务运行器。它使用一个配置文件来设置启动文件、报告器、测试框架、浏览器等等。</li><li id="ef31" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">其余的依赖项主要是我们测试的报告器、使用karma和jasmine的工具以及浏览器启动器。</li></ul><p id="fcb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要运行测试，您只需运行命令“ng test”。这个命令将执行测试，打开浏览器，显示控制台和浏览器报告，同样重要的是，让测试的执行处于观察模式。</p><h2 id="bf5b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">Karma配置</h2><p id="119f" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们来看看angular-cli创建的karma配置文件。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/95cefb232bbcea8235b4b3109fa49d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*cEXorrUPSLypAVtQ_hcUxA.png"/></div></figure><p id="99f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经猜到了这些配置属性的用途，但是让我们来看看其中的一些。</p><ul class=""><li id="6e4e" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">框架:这是jasmine被设置为测试框架的地方。如果你想使用另一个框架，这是一个好地方。</li><li id="418f" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is kx">记者</strong>:这里是你设置记者的地方。您可以更改它们或添加新的。</li><li id="ce4b" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is kx">自动观察</strong>:如果设置为真，测试以观察模式运行。如果您更改了任何测试并保存了文件，测试将重新构建并重新运行。</li><li id="e402" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is kx">浏览器:</strong>这是您设置运行测试的浏览器的地方。默认情况下，它是chrome浏览器，但你可以安装和使用其他浏览器。</li></ul><h2 id="d362" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">测试入口文件</h2><p id="a2d6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">karma的angular-cli配置使用文件“test.ts”作为应用程序测试的入口点。让我们看看那个文件。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/67028b2ea23586f6378718092e994c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*hqPhi8gadWiYajEacEYy-A.png"/></div></figure><p id="14c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们这里有很多事情要做。你可能永远不需要修改这个文件，但是让我们来讨论一些正在发生的事情；</p><ul class=""><li id="2785" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">正在使用文件开头的所有导入创建一个运行角度测试的环境。</li><li id="47d9" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">TestBed是angular提供的一个强大的单元测试工具，它在这个文件中初始化。</li><li id="c5cf" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">最后，karma加载应用程序的所有测试文件，根据正则表达式匹配它们的名称。我们的应用程序文件夹中所有名称中带有“spec.ts”的文件都被视为测试。</li></ul><h2 id="7141" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">我们的第一个测试</h2><p id="6230" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们创建我们的第一个测试。让我们对我们的app.component.ts这样做。这个组件只有一个值为“Angular Unit Testing”的属性“text ”,它呈现在HTML中的“h1”标记内，它还包含路由根元素和一些路由链接。让我们创建一个测试文件来检查组件是否真的具有那个属性，并且真的在HTML中呈现。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/fd2272312980af087836cd6ca33b819a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CklcdftSg9EFGsU20ZwdJg.png"/></div></div></figure><p id="95ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这里发生的一切；</p><ul class=""><li id="4083" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">我们导入所有将要使用的角度测试工具。</li><li id="1319" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">我们导入该组件的所有依赖项。</li><li id="dee2" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">我们使用一个“describe”来开始我们的测试块，其标题与被测试的组件名称相匹配。</li><li id="712b" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">我们在每个之前使用一个异步。异步的目的是让所有可能的异步代码在继续之前完成。</li></ul><p id="c679" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在angular中运行任何测试之前，您需要配置一个angular testbed。这允许您为正在测试的组件创建一个角度环境。测试组件需要的任何模块、组件或服务都必须包含在测试床中。最后，在设置配置之后，调用编译组件函数。</p><p id="d135" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于app.component，我们需要配置一个虚拟路由模块，并使用一个提供程序来设置基本href，如果没有这个，测试将不会编译，因为我们正在设置路由模块，它需要一个基本href。</p><p id="c1e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们有两个测试。我们先来看第一个。</p><ul class=""><li id="68fa" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">在第一个测试中，我们检查组件是否在“title”属性中包含了预期的文本。</li><li id="f420" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">首先，我们需要有一个app.component的实例，为此，我们使用angular testbed的create component函数，结果，我们得到一个fixture对象，它将允许我们创建该组件的实例。</li><li id="6dfa" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">现在我们有了app.component的实例，我们可以检查text属性中的值，并使jasmine expect等于预期值。</li></ul><p id="ede3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个测试做了一些类似的事情，但是它检查dom是否呈现了“text”属性。</p><ul class=""><li id="4d6b" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">首先，它执行与其他测试相同的操作，获取app.component fixture，然后执行detect changes函数，该函数将组件更改应用于HTML(在本例中，我们将插值应用于“text”组件属性的DOM)。</li><li id="7bd7" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">然后获取编译后HTML的原生元素(组件呈现的HTML)。</li><li id="7cae" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">最后，我们选择包含“文本”值的“h1 ”,并期望所选的HTML包含预期的值。</li></ul><h2 id="176e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">测试表单</h2><p id="728e" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">现在让我们看看如何测试一个角形。我们先来看contact.component HTML</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/4c8bbafc4da2237f542e4b55197d2495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*tzmzPcd-vba12zxGWn2Bpw.png"/></div></div></figure><p id="fb8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很简单，不需要任何解释。这只是一个使用窗体控件的规则角形。如果表单无效，提交按钮将被禁用。</p><p id="ef56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看，contact.component</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/25bf8411a03984d8334e8e2bc658beed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*8rM0lMuZht9UqPZwNPq9tQ.png"/></div></figure><p id="f9fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个组件也很容易理解。提交时函数只是将提交的属性更改为true。联系人表单有三个带有验证的控件。</p><p id="bf02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看，这个组件的测试；</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/473f1364a269eca98b91bd84441d1b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*tuKurSqmjgQKt9gEaiudEA.png"/></div></figure><p id="2aa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与我们之前看到的测试相比，这次测试有许多不同之处，不要担心，我们将逐一讨论。</p><ul class=""><li id="bd7e" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">首先，我们有import部分，这里没有什么奇怪的，除了我们引入了“By ”,它允许我们从DOM中选择元素。</li><li id="6f25" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">我们用要测试的组件的名称来声明测试块。</li><li id="e98f" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">我们将创建一些测试范围的对象，我们将在不同的测试中使用它们，这些测试将在“beforeEach”中初始化。</li><li id="70a7" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">“beforeEach”的第一部分是设置启动测试模块所需的所有依赖项。我们已经提到了“异步”的原因。</li><li id="105b" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">在这个例子中，我们使用“compileComponents”函数返回的承诺。当承诺被解决时，我们给每个变量赋值，我们在开始时声明。</li><li id="f324" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">第一个测试只是期望组件实例具有“text”属性的预期值。</li><li id="d3b8" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">第二个测试期望当调用“onSubmit”函数时，组件“submitted”的属性为真。</li><li id="c0cc" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">第三个测试使用“fixture”对象的函数“detectChanges”将组件状态应用于HTML，然后从DOM获取提交按钮并触发click事件。在这之前，我们在组件的“onSubmit”函数上创建一个jasmine“spy”。最后，我们希望不要执行spied函数，因为表单无效，按钮应该被禁用。</li><li id="69b0" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">第四个测试为组件表单设置了无效值，并期望表单有效属性为false。</li><li id="d209" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated">最后，在第五个测试中，我们为表单设置了有效值，并期望表单valid属性为true。</li></ul><p id="79b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在结束这篇文章之前，让我们再看一样东西。我们将看到当我们测试的组件使用服务时，如何处理服务。</p><h2 id="a269" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">用服务测试组件</h2><p id="92d9" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">正如我们已经看到的，当您要用服务测试一个组件时，您需要将提供者添加到在“beforeEach”中创建的测试模块中。问题是，你可能不想使用实际的服务，而是一个模拟版本，所以让我们看看如何做到这一点…</p><p id="fb29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们看看组件的实现；</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/5a683b116426bbf4eaf68800e919460b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*g1miNs78i0eeaE5IdeNVWQ.png"/></div></figure><p id="73ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个从服务中获取用户列表的简单组件。</p><p id="2a6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际的服务实现并不重要，它可以从任何地方获取用户，但是让我们看看如何为模拟服务实现的组件创建测试。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/e29e09e88d0fc09baebad7cfad01aad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*l1k3QeU_c73CCr-F7nexZw.png"/></div></figure><p id="38da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个测试类似于我们之前看到的例子，有一个主要的区别，在测试模块的提供者声明中，我们告诉模块，当服务“UserService”被注入时，它应该使用“UserServiceMock”来代替。“UserServiceMock”是我们创建的一个虚拟服务，它返回虚拟数据来运行组件的测试。仅此而已，这就是你在测试一个组件时应该如何模拟你的服务。</p><h2 id="da24" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">结论</h2><p id="7b0b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们讨论了一系列特性和示例，试图解释如何测试角度元件，正如您所见，这非常简单，您可以执行任何不同类型的测试。我希望这篇文章能帮助你更好地理解如何使用这些工具来测试angular。</p><p id="af71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lk" href="https://github.com/SantiagoGdaR/angular4-unit-test" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a></p></div></div>    
</body>
</html>