<html>
<head>
<title>Components testing in React: what and how to test with Jest and Enzyme.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的组件测试:用Jest和Enzyme测试什么以及如何测试。</h1>
<blockquote>原文：<a href="https://medium.com/swlh/components-testing-in-react-what-and-how-to-test-with-jest-and-enzyme-7c1cace99de5?source=collection_archive---------0-----------------------#2018-10-03">https://medium.com/swlh/components-testing-in-react-what-and-how-to-test-with-jest-and-enzyme-7c1cace99de5?source=collection_archive---------0-----------------------#2018-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ffc5bee75d9c95c6020895011f74d2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gMyWFlVsVIL3b9MB4dUBQ.png"/></div></div></figure><blockquote class="iq ir is"><p id="d4d5" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇关于<a class="ae js" href="https://djangostars.com/blog/what-and-how-to-test-with-enzyme-and-jest-full-instruction-on-react-component-testing/?utm_source=medium&amp;utm_medium=freecodecamp.org&amp;utm_campaign=components%20testing&amp;utm_content=react%20components%20testing" rel="noopener ugc nofollow" target="_blank"> react组件测试</a>的文章是由Django Stars的前端工程师Alona Pysarenko撰写的。</p></blockquote><blockquote class="jt"><p id="22b3" class="ju jv hi hj jw jx jy jz ka kb kc jr dx translated"><a class="ae js" href="https://djangostars.com/blog/what-and-how-to-test-with-enzyme-and-jest-full-instruction-on-react-component-testing/?utm_source=medium&amp;utm_medium=freecodecamp.org&amp;utm_campaign=components%20testing&amp;utm_content=read%20more%20on%20ds%20blog" rel="noopener ugc nofollow" target="_blank">在Django Stars博客</a>上阅读原文。</p></blockquote><p id="1aa3" class="pw-post-body-paragraph it iu hi iw b ix kd iz ja jb ke jd je kf kg jh ji kh ki jl jm kj kk jp jq jr hb bi translated">测试React组件对于初学者以及已经从事过测试的<a class="ae js" href="https://djangostars.com/services/web-development/?utm_source=medium&amp;utm_medium=freecodecamp.org&amp;utm_campaign=components%20testing&amp;utm_content=experienced%20developers" rel="noopener ugc nofollow" target="_blank">经验丰富的开发人员</a>来说可能是一个挑战。将您自己的方法与我们在项目中使用的方法进行比较可能会很有趣。为了覆盖代码库，您必须知道哪些组件必须被测试，以及组件中的哪些代码应该被覆盖。</p><p id="9fc1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">在本文中，我将讨论以下主题:</p><ul class=""><li id="935a" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">根据项目结构定义组件测试的正确顺序</li><li id="746d" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">找出测试覆盖中要省略的内容(不要测试的内容)</li><li id="e8af" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">确定快照测试的必要性</li><li id="6703" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">定义组件中要测试的内容以及测试顺序</li><li id="791e" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">提供详细的自定义代码示例</li></ul><p id="b5f3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">这篇文章要求你有关于Jest和酶设置的知识。关于安装和配置的信息可以很容易地在他们的官方网站上找到。</p><p id="afaa" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">假设以下情况:您需要用测试覆盖项目代码库。你应该从什么开始，在测试的最后你应该得到什么？100%的测试覆盖率？这是你应该向往的基准，但在大多数情况下你不会得到它。</p><p id="cfd2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">为什么？因为你不应该测试所有的代码。我们将找出为什么以及什么应该被排除在测试之外。更重要的是，100%的测试覆盖率并不总是确保组件被完全测试。也不能保证它会通知你是否有什么改变。不要追求百分比，避免编写虚假的测试，尽量不要丢失主要的组件细节。</p><h1 id="09b8" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">根据项目结构定义组件测试的正确顺序</h1><p id="1cad" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">让我们在项目结构的下一部分讨论这个问题:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/cb9ca34322be5bbe7a1688eac4d6bc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3z4TeyTJt_o6_Ca1.png"/></div></div></figure><p id="85e4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我选择了<code class="du mh mi mj mk b">shared</code>目录，因为它是最重要的。它由项目的几个不同页面中使用的组件组成。它们是可重用的，通常很小，也不复杂。如果一个或另一个组件出现故障，将会导致其他地方出现故障。这就是为什么我们应该确信它们是否写得正确。该目录的结构分为几个文件夹，每个文件夹包含组件。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/d681ac881d3eb00be5d9665a69e116c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-8QXMbnFDyLCl81i.png"/></div></div></figure><p id="3fa2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">如何在<code class="du mh mi mj mk b">shared</code>目录中定义组件测试的正确顺序:</p><ul class=""><li id="24bb" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">永远遵循从简单到复杂的原则。分析每个目录并定义哪些组件是<code class="du mh mi mj mk b">independent</code>——也就是说，它们的呈现不依赖于其他组件。它们是独立完成的，可以作为一个单元单独使用。从上面的结构来看，是<code class="du mh mi mj mk b">forms</code>文件夹中的<code class="du mh mi mj mk b">inputs</code>目录。它包含redux-forms的输入组件，如TextInput、SelectInput、CheckboxInput、DateInput等。</li><li id="23ac" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">接下来，我们需要定义<code class="du mh mi mj mk b">inputs</code>组件中经常使用的辅助组件，但应该与它们分开测试。这是<code class="du mh mi mj mk b">utils</code>目录。这个文件夹中的组件并不复杂，但是非常重要。它们通常是可重用的，有助于重复操作。</li><li id="0419" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">下一步是定义哪些组件也可以独立使用。如果有的话，带他们去化验。从我们的结构来看，它是<code class="du mh mi mj mk b">widgets</code>，具有简单功能的小组件。它们将是测试覆盖队列中的第三个项目。</li><li id="5f33" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">此外，分析其余的目录并定义更复杂的组件，这些组件可以单独使用，也可以与其他组件结合使用。在我们的例子中，它是<code class="du mh mi mj mk b">modals</code>目录。这些组件将在下面详细解释。</li><li id="950d" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">最复杂的组件被留到了最后。它们是<code class="du mh mi mj mk b">forms</code>文件夹中的<code class="du mh mi mj mk b">hoc</code>目录和<code class="du mh mi mj mk b">fields</code>。你怎么定义应该先测试哪一个？我从目录中取出已经在测试组件中使用的组件。因此，<code class="du mh mi mj mk b">hoc</code>目录中的组件出现在<code class="du mh mi mj mk b">widgets</code>组件中。这就是为什么我已经知道这个目录及其组件在哪里使用以及用于什么目的。</li><li id="d7fb" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">最后一个是<code class="du mh mi mj mk b">fields</code>文件夹。它包含与redux-forms连接的组件。</li></ul><p id="0509" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">最终的组件顺序(基于我们的示例)如下所示:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/038dada0ece9d842fd6c60eea4530bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3uYj1A00ydreuO0L.png"/></div></div></figure><p id="ef13" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">按照这个顺序，您一步一步地增加被测试组件的复杂性。因此，当操作更复杂的组件时，您已经知道最小的组件是如何工作的。</p><p id="8520" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">例如，如果您不确定如何测试“文本”字段，请不要将“数组”字段作为测试对象。如果没有测试过“表单”字段本身，就不要使用用redux-form修饰的组件。</p><p id="d970" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">选择要一致，不要拿第一个想到的组件，切换逻辑。当然，项目的结构可以不同。它可以有其他目录名，也可以有附加的组件、动作和缩减器，但是定义组件测试顺序的逻辑是相同的。</p><figure class="md me mf mg fd ij er es paragraph-image"><a href="https://djangostars.com/services/web-development/?utm_source=medium&amp;utm_medium=freecodecamp.org&amp;utm_campaign=components%20testing&amp;utm_content=frontend_banner"><div class="er es ml"><img src="../Images/c44c2d266efc13d51f8afb52abffd8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXvQcmeNupo-iVkclcxrSg.png"/></div></a></figure><p id="121a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">让我们定义一下在测试覆盖中应该省略什么:</strong></p><ul class=""><li id="43e0" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated"><strong class="iw mm">第三方库</strong>。不要测试来自另一个库的功能。你不用对代码负责。如果你需要它来测试你的代码，跳过它或者模仿实现。</li><li id="1c44" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated"><strong class="iw mm">常量</strong>。名字本身就说明了一切。它们是不可改变的。它们是静态代码集，不打算改变。</li><li id="fc62" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated"><strong class="iw mm">内联样式</strong>(如果你在你的组件中使用它们的话)。为了测试内联样式，您需要在测试中复制带有样式的对象。如果对象样式改变，您也必须在测试中改变它们。不要在测试中重复一个组件的代码。你永远不会记得在测试中改变它。此外，你的同事永远不会意识到有重复。在大多数情况下，内联样式不会改变组件的行为，所以不应该测试它们。如果你的风格是动态变化的，可能会有一个例外。</li><li id="a28c" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated"><strong class="iw mm">与被测部件无关的事情</strong>。跳过测试组件中导入的测试组件。小心它是否被另一个包裹着。不测试包装器，分别分析测试就好。</li></ul><p id="1a7e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">那么，实际上如何编写测试呢？我结合了两种测试方法:</p><ul class=""><li id="ba8b" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">快照测试</li><li id="b3a3" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">组件逻辑测试</li></ul><p id="8c22" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我现在将讨论这两个问题。</p><h1 id="12c8" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">如何使用快照进行测试</h1><p id="5042" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">如果你想确定用户界面没有改变，快照测试是一个有用的测试工具。第一次面对这个测试工具时，您可能会有关于组织和管理快照的问题。原理很简单，可惜哪里都没有完整描述过。</p><p id="0443" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">第一步。</strong>为组件编写测试，并在expect块中使用创建<code class="du mh mi mj mk b">Snapshot</code>本身的<code class="du mh mi mj mk b">.toMatchSnapshot()</code>方法:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="df79" class="mr la hi mk b fi ms mt l mu mv">it('render correctly text component', () =&gt; {  <br/>    const TextInputComponent = renderer.create(&lt;TextInput /&gt;).toJSON();<br/>    expect(TextInputComponent).toMatchSnapshot();<br/>});</span></pre><p id="6c2c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">第二步。</strong>当您第一次在一个级别上运行测试时，将会创建一个名为<code class="du mh mi mj mk b">__snapshots__</code>的目录，其中包含自动生成的文件，扩展名为<code class="du mh mi mj mk b">.snap</code>。</p><p id="2ac0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">快照如下所示:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="94e0" class="mr la hi mk b fi ms mt l mu mv">// Jest Snapshot v1, <a class="ae js" href="https://goo.gl/fbAQLP" rel="noopener ugc nofollow" target="_blank">https://goo.gl/fbAQLP</a></span><span id="2c2d" class="mr la hi mk b fi mw mt l mu mv">exports[`Render TextInput correctly component 1`] = `  <br/>&lt;input  <br/>  className="input-custom"<br/>  disabled={undefined}<br/>  id={undefined}<br/>  name={undefined}<br/>  onBlur={undefined}<br/>  onChange={[Function]}<br/>  pattern={undefined}<br/>  placeholder={undefined}<br/>  readOnly={false}<br/>  required={undefined}<br/>  type="text"<br/>  value={undefined}<br/>/&gt;<br/>`;</span></pre><p id="e3ab" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">第三步。</strong>将快照放入存储库中，并与测试一起存储。</p><p id="d680" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">如果组件已经更改，您只需使用<code class="du mh mi mj mk b">—updateSnapshot</code>标志或使用简写形式的<code class="du mh mi mj mk b">u</code>标志来更新快照。</p><h1 id="55e0" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">因此，创建了快照—它是如何工作的？</h1><p id="d1f6" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">让我们考虑两种情况:</p><h2 id="35af" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">1.组件已更改</h2><ul class=""><li id="49ad" class="kl km hi iw b ix lx jb ly kf nk kh nl kj nm jr kq kr ks kt bi translated">运行测试</li><li id="ecbf" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">新的快照被创建，它与存储在<code class="du mh mi mj mk b">__snapshots__</code>目录中的自动生成的快照进行比较</li><li id="0054" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">测试失败，因为快照不同</li></ul><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/1fbe47efc6ca78a6af0fbea9396b391b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sU9qGgZCbIQvnhIB.gif"/></div></div></figure><h2 id="960f" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">2.组件没有改变</h2><ul class=""><li id="d101" class="kl km hi iw b ix lx jb ly kf nk kh nl kj nm jr kq kr ks kt bi translated">运行测试</li><li id="c4b4" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">创建新的快照，并与存储在<code class="du mh mi mj mk b">__snapshots__</code>目录中的自动生成的快照进行比较</li><li id="590b" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">测试通过，因为快照相同</li></ul><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/62a27776a8c266110c0d91db10c671e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FECOnZNmc2PRUIR5.gif"/></div></div></figure><p id="ff39" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">当我们测试一个没有逻辑(只有UI渲染)的小组件时，一切都很好。但是实践表明，在真实的项目中没有这样的组件。如果有，也是少数。</p><p id="b067" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">是否有足够的快照用于全面的组件测试？</strong></p><h1 id="df3c" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">组件测试的主要说明</h1><h2 id="492a" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 1。一个组件应该只有一个快照。</strong></h2><p id="bbe7" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">如果一个快照失败，其他快照很可能也会失败。不要创建和存储一堆不必要的快照，它们会堵塞空间，让那些在你之后阅读你的测试的开发人员感到困惑。</p><p id="fc22" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">当然，当您需要在两种状态下测试组件的行为时，也有例外:例如，在打开弹出窗口之前和打开之后的组件状态中。</p><p id="8437" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">然而，即使是这样的变体也总是可以被这个替换:第一个测试存储组件的默认状态，在快照中没有弹出窗口，第二个测试模拟事件并检查特定类的存在。通过这种方式，您可以轻松地绕过创建多个快照。</p><h2 id="4cfa" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 2。测试道具</strong></h2><p id="1886" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">通常，我将道具的测试分为两个测试:</p><ul class=""><li id="d377" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">首先，检查默认属性值的渲染。当组件被渲染时，我期望一个值等于<code class="du mh mi mj mk b">defaultProps</code>，以防这个道具有<code class="du mh mi mj mk b">defaultProps</code>。</li><li id="5d4b" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">其次，检查道具的自定义值。我设置了自己的值，并期望在组件呈现后收到它。</li></ul><h2 id="1ace" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 3。测试数据类型</strong></h2><p id="a53c" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">为了测试道具中出现了什么类型的数据，或者在某些动作之后获得了什么类型的数据，我们可以使用特殊的库jest-extended(附加jest匹配器)，它有一个Jest中没有的扩展匹配集。有了这个库，测试数据类型变得更加容易和有趣。</p><p id="1ea5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">另一方面，测试proptypes是一个矛盾的问题。一些开发人员可能会反对proptypes测试，因为它是第三方包，不应该进行测试。尽管如此，我坚持测试组件的proptypes，因为我不测试包功能本身。相反，我只是确保属性类型是正确的。数据类型是非常重要的编程部分，不应该被忽略。</p><h2 id="f431" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 4。事件测试</strong></h2><p id="ce9d" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">创建快照并用测试覆盖props之后，您可以确保组件将正确呈现。但是如果组件中有事件，这还不足以覆盖全部。</p><p id="cc03" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">您可以用几种方法检查事件。最广泛使用的是:</p><ul class=""><li id="181e" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">模拟事件= &gt;模拟它= &gt;调用了预期事件</li><li id="e3bc" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">模拟事件= &gt;用参数模拟事件= &gt;用传递的参数调用预期事件</li><li id="bcf1" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">传递必要的属性= &gt;渲染组件= &gt;模拟事件= &gt;在被调用的事件上预期某种行为</li></ul><h2 id="a327" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 5。测试条件</strong></h2><p id="4462" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">通常情况下，您可以为特定类的输出设置条件，呈现代码的某一部分，转移所需的道具，等等。不要忘记这一点，因为使用默认值，只有一个分支将通过测试，而第二个分支将保持未测试。</p><p id="b5dd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">在具有计算和大量条件的复杂组件中，您可能会错过一些分支。为了确保代码的所有部分都被测试覆盖，可以使用测试覆盖工具，直观地检查哪些分支被覆盖，哪些没有被覆盖。</p><h2 id="64f7" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated"><strong class="ak"> 6。测试</strong>状态</h2><p id="12f5" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">为了检查状态，在大多数情况下，有必要编写两个测试:</p><ul class=""><li id="e7c9" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">第一个检查当前状态。</li><li id="ce8a" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">第二个在调用事件后检查状态。Render component = &gt;在测试中直接调用函数= &gt;检查状态是如何改变的。要调用组件的函数，您需要获得组件的一个实例，然后调用它的方法(示例在下一个测试中显示)。</li></ul><p id="630f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">在您完成这个说明列表后，您的组件将被覆盖90%到100%。我将10%留给文章中没有描述、但代码中可能出现的特殊情况。</p><h1 id="d640" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试示例</h1><p id="f352" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">让我们转到例子，用测试覆盖组件，就像我们在上面一步一步描述的那样。</p><h2 id="f428" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">1.从表单/输入测试组件。</h2><p id="c787" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">从表单/输入目录中取出一个组件。假设它是datepicker字段的组件DateInput.js。</p><p id="76ea" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">被测组件代码清单:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/forms/inputs/DateInput.js" rel="noopener ugc nofollow" target="_blank"><strong class="iw mm">date input . js</strong></a><strong class="iw mm"><br/>如下:</strong></p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es no"><img src="../Images/053d23102a4978d0f807acc6cc3c04e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/0*iPgLFPVUUnqkPm2V.gif"/></div></figure><p id="fa0f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">DateInput组件使用react-datepicker库，有两个实用程序:</p><ul class=""><li id="73cc" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">valueToDate(将值转换为日期)</li><li id="740e" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">dateToValue(将日期转换为值)</li></ul><p id="360e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">这个包是用来处理数据的，而PropTypes是用来检查React属性的。</p><p id="716c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">根据组件代码，我们可以看到帮助组件渲染的默认属性列表:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="11f2" class="mr la hi mk b fi ms mt l mu mv">const defaultProps = {  <br/>    inputClassName: 'input-custom',<br/>    monthsShown: 1,<br/>    dateFormat: 'DD.MM.YYYY',<br/>    showMonthYearsDropdowns: false,<br/>    minDate: moment()<br/>};</span></pre><p id="c62e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">所有的道具都适合创建快照，除了一个:<code class="du mh mi mj mk b">minDate: moment()</code>。moment()将在我们每次运行测试时给出当前日期，而快照将会失败，因为它存储了过期的日期。解决方案是模仿这个值:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="2643" class="mr la hi mk b fi ms mt l mu mv">const defaultProps = {  <br/>    minDate: moment(0)<br/>}</span></pre><p id="c36f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我们需要在每个渲染组件中使用minDate prop。为了避免道具重复，我创建了HOC，它接收defaultProps并返回一个漂亮的组件:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="3f5c" class="mr la hi mk b fi ms mt l mu mv">import TestDateInput from '../DateInput';  <br/>const DateInput = (props) =&gt;  <br/>    &lt;TestDateInput<br/>        {...defaultProps}<br/>        {...props}<br/>    /&gt;;</span></pre><p id="eea2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">不要忘记<code class="du mh mi mj mk b">moment-timezone</code>，尤其是如果您的测试将由来自不同时区的另一个国家的开发人员运行。他们将收到模拟值，但会有时区转换。解决方法是设置一个默认时区:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="ec68" class="mr la hi mk b fi ms mt l mu mv">const moment = require.requireActual('moment-timezone').tz.setDefault('America/Los_Angeles')</span></pre><p id="9620" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">现在，日期输入组件已经准备好进行测试了:</p><p id="9f49" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 1。首先创建快照:</strong></p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="b1ad" class="mr la hi mk b fi ms mt l mu mv">it('render correctly date component', () =&gt; {  <br/>    const DateInputComponent = renderer.create(&lt;DateInput /&gt;).toJSON();<br/>    expect(DateInputComponent).toMatchSnapshot();<br/>});</span></pre><p id="f2e2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 2。测试道具:</strong></p><p id="151f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">浏览道具，找到重要的。要测试的第一个道具是showMonthYearsDropdowns。如果设置为true，则显示月份和年份的下拉列表:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="8eab" class="mr la hi mk b fi ms mt l mu mv">it('check month and years dropdowns displayed', () =&gt; {  <br/>    const props = {<br/>            showMonthYearsDropdowns: true<br/>        },<br/>        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find('.datepicker');<br/>    expect(DateInputComponent.hasClass('react-datepicker-hide-month')).toEqual(true);<br/>});</span></pre><p id="aec6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">测试空属性值。需要进行此检查，以确保组件在没有定义值的情况下呈现:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="ad96" class="mr la hi mk b fi ms mt l mu mv">it('render date input correctly with null value', () =&gt; {  <br/>    const props = {<br/>            value: null<br/>        },<br/>        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);<br/>    expect((DateInputComponent).prop('value')).toEqual(null);<br/>});</span></pre><p id="e487" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 3。值的测试属性类型，日期应为字符串:</strong></p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="7d73" class="mr la hi mk b fi ms mt l mu mv">it('check the type of value', () =&gt; {  <br/>    const props = {<br/>            value: '10.03.2018'<br/>        },<br/>        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);<br/>    expect(DateInputComponent.prop('value')).toBeString();<br/>});</span></pre><p id="e617" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 4。测试事件:</strong></p><p id="400d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">首先，检查onChange事件。</p><ul class=""><li id="85f2" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">模拟onChange回调</li><li id="3eef" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">呈现日期输入组件</li><li id="90d7" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">用新的目标值模拟变更事件</li><li id="f6de" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">最后检查onChange事件是否已用新值调用。</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="e1a6" class="mr la hi mk b fi ms mt l mu mv">it('check the onChange callback', () =&gt; {  <br/>    const onChange = jest.fn(),<br/>        props = {<br/>            value: '20.01.2018',<br/>            onChange<br/>        },<br/>        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find('input');<br/>    DateInputComponent.simulate('change', { target: {value: moment('2018-01-22')} });<br/>    expect(onChange).toHaveBeenCalledWith('22.01.2018');<br/>});</span></pre><p id="6fc7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">接下来，确保datepicker弹出窗口在单击日期输入后打开。为此，find date input = &gt; simulate click event = &gt;并期望当类<code class="du mh mi mj mk b">.react-datepicker</code>出现时弹出。</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="f4c2" class="mr la hi mk b fi ms mt l mu mv">it('check DatePicker popup open', () =&gt; {  <br/>    const DateComponent = mount(&lt;DateInput /&gt;),<br/>        dateInput = DateComponent.find("input[type='text']");<br/>    dateInput.simulate('click');<br/>    expect(DateComponent.find('.react-datepicker')).toHaveLength(1);<br/>});</span></pre><p id="dfc9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">全面测试清单:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/forms/inputs/__tests__/DateInput.test.js" rel="noopener ugc nofollow" target="_blank"> DateInput.test.js </a></p><h2 id="3f32" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">2.效用测试:</h2><p id="2eb0" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated"><strong class="iw mm">测试实用程序的代码列表:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/utils/valueToDate.js" rel="noopener ugc nofollow" target="_blank"> valueToDate.js </a></p><p id="7bd7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">该实用程序的目的是将一个值转换为具有自定义格式的日期。</p><p id="0012" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">首先，让我们分析给定的实用程序，并定义测试的主要情况:</p><ol class=""><li id="3009" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr np kr ks kt bi translated">根据这个实用程序的目的，它转换值，所以我们需要检查这个值:</li></ol><ul class=""><li id="9c32" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">如果没有定义值:我们需要确保实用程序不会返回异常(错误)。</li><li id="745d" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">如果定义了值:我们需要检查实用程序是否返回了当前日期。</li></ul><p id="5618" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">2.返回值应该属于moment类。这就是为什么它应该是一个瞬间的例子。</p><p id="7e62" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">3.第二个参数是dateFormat。测试前将其设置为常量。这就是为什么它会在每个测试中传递，并根据日期格式返回值。我们应该单独测试日期格式吗？我想不会。这个参数是可选的——如果我们不设置dateFormat，这个实用程序不会中断，它只会以默认格式返回日期。这是一个临时的工作，我们不应该测试第三方库。正如我之前提到的，我们不应该忘记时间时区；这是非常重要的一点，尤其是对于来自不同时区的开发者来说。</p><p id="9965" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">咱们来码:</strong></p><ol class=""><li id="330c" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr np kr ks kt bi translated"><strong class="iw mm">为第一个案例编写测试。当我们没有价值的时候，它就是空的。</strong></li></ol><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="fe1e" class="mr la hi mk b fi ms mt l mu mv">const format = 'DD.MM.YYYY';</span><span id="ff90" class="mr la hi mk b fi mw mt l mu mv">it('render valueToDate utility with empty value', () =&gt; {  <br/>    const value = valueToDate('', format);<br/>    expect(value).toEqual(null);<br/>});</span></pre><p id="a78f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 2。检查值是否已定义。</strong></p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="9b40" class="mr la hi mk b fi ms mt l mu mv">const date = '21.11.2015',  <br/>      format = ‘DD.MM.YYYY’;</span><span id="b685" class="mr la hi mk b fi mw mt l mu mv">it('render valueToDate utility with defined value', () =&gt; {  <br/>    const value = valueToDate(date, format);<br/>    expect(value).toEqual(moment(date, format));<br/>});</span></pre><p id="c0af" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 3。检查该值是否属于力矩类。</strong></p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="5470" class="mr la hi mk b fi ms mt l mu mv">const date = '21.11.2015',  <br/>    format = 'DD.MM.YYYY';</span><span id="3d61" class="mr la hi mk b fi mw mt l mu mv">it('check value is instanceof moment', () =&gt; {  <br/>    const value = valueToDate(date, format);<br/>    expect(value instanceof moment).toBeTruthy();<br/>});</span></pre><p id="bec8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/utils/__tests__/valueToDate.test.js" rel="noopener ugc nofollow" target="_blank">valuetodate . test . js</a></p><h2 id="9fb5" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">3.小部件测试</h2><p id="bff3" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">对于小部件测试，我使用了一个旋转器组件。</p><p id="015e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">被测小工具代码清单:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/widgets/Spinner.js" rel="noopener ugc nofollow" target="_blank"> Spinner.js </a></p><p id="8575" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">看起来像这样:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/7feb870273d045293443f414e8d658c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UM7UiX6_03MeuYmR.gif"/></div></div></figure><p id="d0e8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">解释中不需要spinner，因为几乎所有的web资源都有这个组件。</p><p id="027c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">所以如果我们去写测试:</p><ol class=""><li id="c3ec" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr np kr ks kt bi translated"><strong class="iw mm">第一步—创建快照:</strong></li></ol><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="4f35" class="mr la hi mk b fi ms mt l mu mv">it('render correctly Spinner component', () =&gt; {  <br/>   const SpinnerComponent = mount(&lt;Spinner /&gt;);<br/>   expect(SpinnerComponent).toMatchSnapshot();<br/>});</span></pre><p id="93e4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 2。测试道具:</strong></p><p id="ab0a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">首先，我们查看默认道具标题，并检查它是否正确渲染。</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="52a4" class="mr la hi mk b fi ms mt l mu mv">it('check prop title by default', () =&gt; {  <br/> const SpinnerComponent = mount(&lt;Spinner /&gt;);<br/>    expect(SpinnerComponent.find('p').text()).toEqual('Please wait');<br/>});</span></pre><p id="8c92" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">然后我们检查自定义道具标题。我们需要检查它是否返回了正确定义的属性。看一下代码，标题是用rawMarkup util包装的，借助dangerouslySetInnerHTML属性输出。</p><p id="3e4d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">rawMarkup util的代码列表:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="d974" class="mr la hi mk b fi ms mt l mu mv">export default function rawMarkup(template) {  <br/>    return {__html: template};<br/>}</span></pre><p id="097f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我们需要在spinner组件中包含rawMarkup的测试吗？不，它是一个独立的工具，应该与旋转器分开测试。我们不关心它是如何工作的——我们只需要知道title prop返回正确的结果。</p><p id="56b1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">澄清:使用dangerouslySetInnerHTML属性的原因如下。我们的网站是多语言的，由翻译营销团队负责。他们可以简单地用单词组合来翻译，甚至用HTML标签来装饰，比如<code class="du mh mi mj mk b">&lt;strong&gt;</code>、<code class="du mh mi mj mk b">&lt;i&gt;</code>、<code class="du mh mi mj mk b">&lt;s&gt;</code>，甚至用列表<code class="du mh mi mj mk b">&lt;ol&gt;</code>、<code class="du mh mi mj mk b">&lt;ul&gt;</code>来分割文本。我们不确定他们是如何翻译和修饰文本的。我们只需要正确地渲染这些东西。</p><p id="5501" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我在一个测试中结合了两个主要的测试用例:</p><ul class=""><li id="161c" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">返回正确的自定义道具标题</li><li id="cb80" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">使用HTML标签正确呈现属性标题</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="0710" class="mr la hi mk b fi ms mt l mu mv">it('check prop title with html tags', () =&gt; {  <br/>    const props = {<br/>            title: '&lt;b&gt;Please wait&lt;/b&gt;'<br/>        },<br/>        SpinnerComponent = mount(&lt;Spinner {...props} /&gt;);<br/>    expect(SpinnerComponent.find('p').text()).toEqual('Please wait');<br/>});</span></pre><p id="de37" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">取下一个道具字幕。它是可选的，这就是为什么它没有默认道具，所以跳过默认道具这一步，测试自定义道具:</p><ul class=""><li id="8518" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">检查字幕中文本是否正确呈现:</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6608" class="mr la hi mk b fi ms mt l mu mv">const props = {  <br/>        subTitle: 'left 1 minute'<br/>    },<br/>    SpinnerComponent = mount(&lt;Spinner {...props} /&gt;);</span><span id="c088" class="mr la hi mk b fi mw mt l mu mv">it('render correct text', () =&gt; {  <br/>    expect(SpinnerComponent.find('p').at(1).text()).toEqual(props.subTitle);<br/>});</span></pre><p id="c3d2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我们知道字幕是可选的。这就是为什么我们需要根据切片标记检查它是否是用默认道具渲染的。只需检查标签数量<code class="du mh mi mj mk b">&lt;p&gt;</code>:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="0c6d" class="mr la hi mk b fi ms mt l mu mv">it('check subTitle is not rendered', () =&gt; {  <br/>  const SpinnerComponent = mount(&lt;Spinner /&gt;);<br/>    expect(SpinnerComponent.find('p').length).toEqual(1);<br/>});</span></pre><p id="cea6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 3。测试道具类型:</strong></p><ul class=""><li id="ba64" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">对于预期为字符串的标题属性:</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="f4e7" class="mr la hi mk b fi ms mt l mu mv">it('check prop type for title is string', () =&gt; {  <br/>    const props = {<br/>            title: 'Wait'<br/>        },<br/>        SpinnerComponent = mount(&lt;Spinner {...props} /&gt;);<br/>    expect(SpinnerComponent.find('p').text()).toBeString();<br/>});</span></pre><ul class=""><li id="1cc7" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">对于字幕属性也应该是字符串:</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="13f6" class="mr la hi mk b fi ms mt l mu mv">const props = {  <br/>        subTitle: 'left 1 minute'<br/>    },<br/>    SpinnerComponent = mount(&lt;Spinner {...props} /&gt;);</span><span id="1772" class="mr la hi mk b fi mw mt l mu mv">it('type for subTitle is string', () =&gt; {  <br/>    expect(SpinnerComponent.find('p').at(1).text()).toBeString();<br/>});</span></pre><p id="78ab" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/widgets/__tests__/Spinner.test.js" rel="noopener ugc nofollow" target="_blank"> Spinner.test.js </a></p><h2 id="18e2" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">4.模态测试(ModalWrapper.js和ModalTrigger.js)</h2><p id="c4a9" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated"><strong class="iw mm">看起来像:</strong></p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/d28113254d9f799b03a1c747326528ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yHJepyEsUKrXjt9O.gif"/></div></div></figure><p id="9f4d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">如何测试模态</strong></p><p id="9d83" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">首先，我想解释一下在我们的项目中情态动词是如何组织的。我们有两个组件:<strong class="iw mm"> ModalWrapper.js </strong>和<strong class="iw mm"> ModalTrigger.js </strong>。</p><p id="0a80" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">ModalWrapper 负责弹出布局。它包含模式容器、按钮“关闭”、模式标题和主体。</p><p id="d054" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">模态触发器</strong>负责模态处理。它包括ModalWrapper布局，并包含modal布局控件的事件(打开和关闭操作)。</p><p id="f0db" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我将分别介绍每个组件:</p><p id="90fd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 1。被测组件代码列表:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/modals/ModalWrapper.js" rel="noopener ugc nofollow" target="_blank"> ModalWrapper.js </a></p><p id="8a7f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">咱们码:</strong></p><p id="387a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">首先，ModalWrapper接收组件并在内部呈现它。首先，检查ModalWrapper在没有组件的情况下不会失败。使用默认属性创建快照:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6917" class="mr la hi mk b fi ms mt l mu mv">it('without component', () =&gt; {  <br/>    const ModalWrapperComponent = shallow(&lt;ModalWrapper /&gt;);<br/>    expect(ModalWrapperComponent).toMatchSnapshot();<br/>});</span></pre><p id="abf1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">下一步是用通过props的组件渲染来模拟它的实际情况:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="5fb1" class="mr la hi mk b fi ms mt l mu mv">it('with component', () =&gt; {  <br/>   const props = {<br/>           component: () =&gt; {}<br/>        },<br/>        ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;);<br/>    expect(ModalWrapperComponent).toMatchSnapshot();<br/>});</span></pre><p id="881e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">测试道具</strong></p><p id="80e3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">正在接收自定义类名属性:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="43bf" class="mr la hi mk b fi ms mt l mu mv">it('render correct class name', () =&gt; {  <br/>    const props = {<br/>            modalClassName: 'custom-class-name'<br/>        },<br/>        ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;).find('Modal');<br/>        expect(ModalWrapperComponent.hasClass('custom-class-name')).toEqual(true);<br/>});</span></pre><p id="78ff" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">接收自定义标题属性:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="0324" class="mr la hi mk b fi ms mt l mu mv">it('render correct title', () =&gt; {  <br/>    const props = {<br/>           title: 'Modal Title'<br/>       },<br/>       ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;).find('ModalTitle');<br/>    expect(ModalWrapperComponent.props().children).toEqual('Modal Title');<br/>});</span></pre><p id="2bc0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">接收正确的演出道具:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="dc92" class="mr la hi mk b fi ms mt l mu mv">it('check prop value', () =&gt; {<br/>        const props = {<br/>               show: true<br/>           },<br/>           ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;).find('Modal');<br/>        expect(ModalWrapperComponent.props().show).toEqual(true);<br/>    });</span></pre><p id="d7ba" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">测试prop类型</strong></p><ul class=""><li id="ac3b" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">为了表演道具</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="62a5" class="mr la hi mk b fi ms mt l mu mv">it('check prop type', () =&gt; {  <br/>    const props = {<br/>           show: true<br/>        },<br/>        ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;).find('Modal');<br/>    expect(ModalWrapperComponent.props().show).toBeBoolean();<br/>});</span></pre><ul class=""><li id="9eaa" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">对于舷侧支柱</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="eb49" class="mr la hi mk b fi ms mt l mu mv">it('render correct onHide prop type', () =&gt; {  <br/>    const props = {<br/>            onHide: () =&gt; {}<br/>        },<br/>        ModalWrapperComponent = shallow(&lt;ModalWrapper {...props} /&gt;).find('Modal');<br/>    expect(ModalWrapperComponent.props().onHide).toBeFunction();<br/>});</span></pre><ul class=""><li id="6225" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">对于部件本身</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="13f7" class="mr la hi mk b fi ms mt l mu mv">it(‘render correct component prop type’, () =&gt; {  <br/>   const props = {<br/>           component: () =&gt; {}<br/>       },<br/>       ModalWrapperComponent = mount(&lt;ModalWrapper {...props} /&gt;);<br/>   expect(ModalWrapperComponent.props().component).toBeFunction();<br/>});</span></pre><p id="d78c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/modals/__tests__/ModalWrapper.test.js" rel="noopener ugc nofollow" target="_blank">modal wrapper . test . js</a></p><p id="a1cc" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 2。被测组件代码列表:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/modals/ModalTrigger.js" rel="noopener ugc nofollow" target="_blank"> ModalTrigger.js </a></p><p id="b55d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">模态包装已经包含了一个测试。第二部分将介绍模态触发器组件。</p><p id="ee14" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">组件概述:它基于表明ModalWrapper可见性的状态<code class="du mh mi mj mk b">toggled</code>。如果<code class="du mh mi mj mk b">toggled: false</code>，弹出窗口隐藏，否则可见。函数<strong class="iw mm"> open() </strong>打开子元素上的弹出窗口。click事件和函数<strong class="iw mm"> close() </strong>隐藏在ModalWrapper中呈现的按钮上的弹出窗口。</p><p id="00f4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">快照创建:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6dba" class="mr la hi mk b fi ms mt l mu mv">it('render ModalTrigger component correctly', () =&gt; {  <br/>    const ModalTriggerComponent = shallow(&lt;ModalTrigger&gt;&lt;div /&gt;&lt;/ModalTrigger&gt;);<br/>    expect(ModalTriggerComponent).toMatchSnapshot();<br/>});</span></pre><p id="7407" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">应该用组件道具渲染测试ModalTrigger吗？否—因为<code class="du mh mi mj mk b">component</code>将在ModalWrapper组件中呈现。它不依赖于被测试的组件。它已经包含在ModalWrapper测试中了。</p><p id="1c2a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">测试道具:</p><p id="1511" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我们有一个道具<code class="du mh mi mj mk b">children</code>，我们希望确保我们只有一个孩子。</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="7c57" class="mr la hi mk b fi ms mt l mu mv">it('ensure to have only one child (control element)', () =&gt; {  <br/>    expect(ModalTriggerComponent.findWhere(node =&gt; node.key() === 'modal-control').length).toEqual(1);<br/>});</span></pre><p id="abe7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">测试属性类型:</p><p id="1ff4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">子道具应该是一个对象，所以在下一个测试中检查它:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="9d7f" class="mr la hi mk b fi ms mt l mu mv">const ModalTriggerComponent = mount(&lt;ModalTrigger&gt;&lt;div /&gt;&lt;/ModalTrigger&gt;);</span><span id="b16a" class="mr la hi mk b fi mw mt l mu mv">it('check children prop type', () =&gt; {  <br/>      expect(ModalTriggerComponent.props().children).toBeObject();<br/>});</span></pre><p id="026c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">ModalTrigger组件的一个重要部分是检查状态。</p><p id="3c35" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我们有两种状态:</p><ul class=""><li id="dd2c" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">弹出窗口打开。要知道模态是打开的，我们需要检查它的状态。为此，从组件的实例中调用open函数，并期望状态中的<code class="du mh mi mj mk b">toggled</code>应该为真。</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6334" class="mr la hi mk b fi ms mt l mu mv">it('check the modal is opened', () =&gt; {  <br/>    const event = {<br/>        preventDefault: () =&gt; {},<br/>        stopPropagation: () =&gt; {}<br/>    };<br/>    ModalTriggerComponent.instance().open(event);<br/>    expect(ModalTriggerComponent.state().toggled).toBeTruthy();<br/>});</span></pre><ul class=""><li id="c423" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">弹出窗口已关闭。反之亦然，<code class="du mh mi mj mk b">toggled</code>处于应假状态。</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="591b" class="mr la hi mk b fi ms mt l mu mv">it('check the modal is closed', () =&gt; {  <br/>   ModalTriggerComponent.instance().close();<br/>   expect(ModalTriggerComponent.state().toggled).toBeFalsy();<br/>});</span></pre><p id="e4e6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/modals/__tests__/ModalTrigger.test.js" rel="noopener ugc nofollow" target="_blank">modal trigger . test . js</a></p><p id="28d2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">现在模态已经完全测试过了。测试相互依赖的组件的一个建议是:首先检查组件并编写测试计划，定义每个组件中需要测试的内容，检查每个组件的测试用例，并确保不要在两个组件中重复相同的测试用例。仔细分析测试覆盖的可能的和最佳的变体。</p><h2 id="7976" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">5.特设测试(高阶组件)</h2><p id="411b" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">最后两个部分(HOCs和表单域测试)是相互关联的。我想与你分享如何测试现场布局与它的特设。</p><p id="603c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">下面是对什么是BaseFieldLayout、我们为什么需要这个组件以及我们在哪里使用它的解释:</p><ul class=""><li id="c633" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">js是表单输入组件的包装器，如TextInput、CheckboxInput、DateInput、SelectInput等。它们的名字以<code class="du mh mi mj mk b">-Input</code>结尾，因为我们使用redux-form包，这些组件是redux-form逻辑的输入组件。</li><li id="36e1" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">我们需要BaseFieldLayout来创建表单字段组件的布局，即呈现标签、工具提示、前缀(货币、平方米缩写等。)，图标，错误等等。</li><li id="1c2b" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">我们在BaseFieldHOC.js中使用它来包装字段布局中的input组件，并借助于<code class="du mh mi mj mk b">&lt;Field/&gt;</code>组件将其与redux-form连接起来。</li></ul><p id="d162" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">被测组件代码列表:</strong> <a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/hoc/BaseFieldHOC.js" rel="noopener ugc nofollow" target="_blank"> BaseFieldHOC.js </a></p><p id="12dd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">它是一个接收表单输入组件并返回组件的特设组件，与redux-form连接。</p><p id="3cf4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">分析特设:</p><ul class=""><li id="b29d" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">这个组件只接收一个道具，<code class="du mh mi mj mk b">component</code>。首先，我需要创建这个组件，并将其包装在BaseFieldHOC中。</li><li id="ba82" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">接下来，我需要用redux-form修饰包装后的HOC，以便用redux-form连接字段。</li><li id="a379" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">在React Redux <code class="du mh mi mj mk b">&lt;Provider&gt;</code>组件中呈现这个字段，使测试组件可以使用这个存储。要嘲笑商店，只需:</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="594c" class="mr la hi mk b fi ms mt l mu mv">const store = createStore(() =&gt; ({}));</span></pre><p id="32df" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">现在，在每次测试之前，我需要做以下事情:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="14af" class="mr la hi mk b fi ms mt l mu mv">let BaseFieldHOCComponent;</span><span id="f796" class="mr la hi mk b fi mw mt l mu mv">beforeEach(() =&gt; {  <br/>    const TextInput = () =&gt; { return 'text input'; },<br/>        BaseFieldHOCWrapper = BaseFieldHOC(TextInput),<br/>        TextField = reduxForm({ form: 'testForm' })(BaseFieldHOCWrapper);<br/>    BaseFieldHOCComponent = renderer.create(<br/>        &lt;Provider store={store}&gt;<br/>            &lt;TextField name="text-input" /&gt;<br/>        &lt;/Provider&gt;<br/>    ).toJSON();<br/>});</span></pre><p id="5473" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">之后，组件就可以进行测试了:</p><ol class=""><li id="19c3" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr np kr ks kt bi translated">创建快照:</li></ol><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="3a45" class="mr la hi mk b fi ms mt l mu mv">it('render correctly component', () =&gt; {  <br/>    expect(BaseFieldHOCComponent).toMatchSnapshot();<br/>});</span></pre><p id="2121" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">2.确保呈现后输入组件被包装在BaseFieldLayout中:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6b1f" class="mr la hi mk b fi ms mt l mu mv">it('check input component is wrapped in BaseFieldLayout', () =&gt; {  <br/>    expect(BaseFieldHOCComponent.props.className).toEqual('form-group');<br/>});</span></pre><p id="bd45" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">仅此而已，特设已涵盖。测试与redux-form连接的组件最复杂的部分是准备字段(用redux form装饰并设置存储)。剩下的就简单了，只要按照说明做就行了，别无其他。</p><p id="2f14" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/hoc/__tests__/BaseFieldHOC.test.js" rel="noopener ugc nofollow" target="_blank">basefieldhoc . test . js</a></p><h2 id="dc42" class="mr la hi bd lb mx my mz lf na nb nc lj kf nd ne ln kh nf ng lr kj nh ni lv nj bi translated">6.表单/字段测试</h2><p id="a8e8" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">测试覆盖了域HOC，因此我们可以移动到BaseFieldLayout组件。</p><p id="aee7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">被测组件代码列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/forms/fields/BaseFieldLayout.js" rel="noopener ugc nofollow" target="_blank">basefieldlayout . js</a></p><p id="04d7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">让我们编写BaseFieldLayout.js代码，并根据上面的说明编写测试:</p><ol class=""><li id="343d" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr np kr ks kt bi translated"><strong class="iw mm">首先，创建快照。</strong></li></ol><p id="8c06" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">如果没有defaultProps，将不会呈现此组件:</p><ul class=""><li id="03fe" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">输入组件</li><li id="f50a" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">redux-form提供的道具:输入和元对象。属性名称为的输入和属性错误的元已被触及:</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="a8c5" class="mr la hi mk b fi ms mt l mu mv">const defaultProps = {  <br/>   meta: {<br/>        touched: null,<br/>        error: null<br/>    },<br/>    input: {<br/>        name: 'field-name'<br/>    },<br/>    inputComponent: () =&gt; { return 'test case'; }<br/>}</span></pre><p id="7923" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">要在每个测试的包装器中使用defaultProps，请执行以下操作:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="9fa6" class="mr la hi mk b fi ms mt l mu mv">import TestBaseFieldLayout from '../BaseFieldLayout';</span><span id="2571" class="mr la hi mk b fi mw mt l mu mv">const BaseFieldLayout = (props) =&gt; &lt;TestBaseFieldLayout {...defaultProps} {...props} /&gt;;</span></pre><p id="6d11" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">现在，我们准备创建快照:</p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="6425" class="mr la hi mk b fi ms mt l mu mv">it('render correctly BaseFieldLayout component', () =&gt; {  <br/>    const BaseFieldLayoutComponent = renderer.create(&lt;BaseFieldLayout /&gt;).toJSON();<br/>    expect(BaseFieldLayoutComponent).toMatchSnapshot();<br/>});</span></pre><p id="a50b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 2。测试道具:</strong></p><p id="116b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">这个组件有很多道具。我将展示几个例子，其余的将通过类比进行测试。</p><ul class=""><li id="f488" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">确保<code class="du mh mi mj mk b">icon</code>道具被正确渲染</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="1c4f" class="mr la hi mk b fi ms mt l mu mv">it('render correctly icon prop', () =&gt; {  <br/>    const props = {<br/>            icon: &lt;span className="icon-exclamation" /&gt;<br/>        },<br/>        BaseFieldLayoutComponent = mount(&lt;BaseFieldLayout {...props} /&gt;);<br/>        expect(BaseFieldLayoutComponent.find('span').hasClass('icon-exclamation')).toBeTruthy();<br/>});</span></pre><ul class=""><li id="4959" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">确保工具提示内容呈现在标签旁边</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="47b4" class="mr la hi mk b fi ms mt l mu mv">const props = {  <br/>        labelTooltipContent: 'tooltip for label'<br/>    },<br/>    BaseFieldLayoutComponent = mount(&lt;BaseFieldLayout {...props} /&gt;);</span><span id="0636" class="mr la hi mk b fi mw mt l mu mv">it('check prop is rendered', () =&gt; {  <br/>   expect(BaseFieldLayoutComponent.find('span').hasClass('tooltip-icon')).toBeTruthy();<br/>});</span></pre><ul class=""><li id="b925" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">测试<code class="du mh mi mj mk b">fieldLink</code>道具</li><li id="2c8a" class="kl km hi iw b ix ku jb kv kf kw kh kx kj ky jr kq kr ks kt bi translated">确保默认情况下fieldLink为空</li></ul><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="8317" class="mr la hi mk b fi ms mt l mu mv">it('check prop is null by default', () =&gt; {  <br/>    const BaseFieldLayoutComponent = shallow(&lt;BaseFieldLayout /&gt;);<br/>    expect(BaseFieldLayoutComponent.props().fieldLink).toBe(null);<br/>});</span></pre><ul class=""><li id="1e4f" class="kl km hi iw b ix iy jb jc kf kn kh ko kj kp jr kq kr ks kt bi translated">确保fieldLink使用自定义值正确呈现</li></ul><p id="45af" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm"> 3。测试错误:</strong></p><pre class="md me mf mg fd mn mk mo mp aw mq bi"><span id="d989" class="mr la hi mk b fi ms mt l mu mv">it('check if field has error', () =&gt; {  <br/>    const props = {<br/>            meta: {<br/>                touched: true,<br/>                error: 'This field is required'<br/>            }<br/>        },<br/>        BaseFieldLayoutComponent = mount(&lt;BaseFieldLayout {...props} /&gt;);<br/>    expect(BaseFieldLayoutComponent.find('.error')).toHaveLength(1);<br/>});</span></pre><p id="213e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated"><strong class="iw mm">完整测试列表:</strong><a class="ae js" href="https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/forms/fields/__tests__/BaseFieldLayout.test.js" rel="noopener ugc nofollow" target="_blank">basefieldlayout . test . js</a></p><h1 id="3311" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结果</h1><p id="7fbd" class="pw-post-body-paragraph it iu hi iw b ix lx iz ja jb ly jd je kf lz jh ji kh ma jl jm kj mb jp jq jr hb bi translated">现在您知道了如何基于项目结构执行组件的全覆盖测试。根据我自己的经验，我试图解释什么是测试所必需的，以什么样的顺序，以及在测试覆盖中你可以省略什么。此外，我演示了几个测试组件的例子，并指出代码库覆盖的顺序。</p><p id="1e4e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kf jg jh ji kh jk jl jm kj jo jp jq jr hb bi translated">我希望你会发现这篇文章很有用，并分享你的回答。感谢您的阅读。</p><figure class="md me mf mg fd ij er es paragraph-image"><a href="https://djangostars.com/services/web-development/?utm_source=medium&amp;utm_medium=freecodecamp.org&amp;utm_campaign=components%20testing&amp;utm_content=banner_end"><div class="er es ml"><img src="../Images/c44c2d266efc13d51f8afb52abffd8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXvQcmeNupo-iVkclcxrSg.png"/></div></a></figure><blockquote class="jt"><p id="c957" class="ju jv hi hj jw jx jy jz ka kb kc jr dx translated">如果你觉得这篇文章有用，请点击👏下面的按钮:)</p></blockquote><figure class="ns nt nu nv nw ij"><div class="bz dy l di"><div class="nx ny l"/></div></figure></div></div>    
</body>
</html>