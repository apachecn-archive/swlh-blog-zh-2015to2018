<html>
<head>
<title>Errors are features too</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">错误也是特征</h1>
<blockquote>原文：<a href="https://medium.com/swlh/errors-are-features-too-b4922c7d98f2?source=collection_archive---------20-----------------------#2018-06-13">https://medium.com/swlh/errors-are-features-too-b4922c7d98f2?source=collection_archive---------20-----------------------#2018-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c81c06ec13fc82c68fc25a873d9a7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qki_t1kYSUHXBNiULn20aw.jpeg"/></div></div></figure><p id="989c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有人喜欢错误。</p><p id="893b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而错误仍然存在。分段故障时有发生，蓝屏仍然是一件事，API退回带有5xx状态代码的请求。没有人合理提供100%的正常运行时间。</p><p id="e77d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是大多数时候，在测试新的API时，不太可能会遇到错误。在交付生产之前，您可能不会体验到它们。因此，对于包括Pusher在内的服务提供商来说，优化他们产品中的快乐路径是有意义的。</p><p id="bc71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是过于乐观会造成伤害——错误不会消失，忽视它们会产生负面反馈循环。</p><p id="5e46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切都始于一个糟糕的错误。处理该模块的下一个开发人员会忽略它，并在不重构错误处理逻辑的情况下进行快速更改。下面的开发者也是这么做的。这个循环持续一段时间，技术债务累积，最终导致…</p><blockquote class="jo"><p id="ffa1" class="jp jq hi hj jr js jt ju jv jw jx jn dx translated">应用程序遇到意外错误:无错误。</p></blockquote><p id="8c04" class="pw-post-body-paragraph iq ir hi is b it jy iv iw ix jz iz ja jb ka jd je jf kb jh ji jj kc jl jm jn hb bi translated">如何才能打破这种恶性循环？我们能以同样的尊重对待软件错误和快乐之路吗？</p><p id="df1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Pusher，我们认为错误是特征。我们认为它们应该得到和快乐场景一样多的关注。</p><p id="b76c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解释这一理念，我们将其转化为错误设计的五个原则:</p><ol class=""><li id="1528" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated">针对客户端简单性进行优化。</li><li id="fb7f" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">考虑处理程序的设计错误。</li><li id="d0b6" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">抽象应该减少错误率。</li><li id="19a7" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">提前失效，安全失效。</li><li id="d36a" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">提供可操作的错误细节。</li></ol><p id="54fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们不仅减少了处理错误的挫折感，还提高了我们服务的可靠性。</p><h1 id="0859" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">1.针对客户端简单性进行优化</h1><p id="1b15" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">Pusher的目标是用更简单、更易管理的接口将复杂的通信问题封装到服务中。这种将复杂性转移到服务器的理念减少了我们客户的工作量，帮助他们用更少的代码完成更多的工作。</p><p id="6213" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">遵循这条规则，<strong class="is lu">我们必须保持简单的客户端错误处理行为</strong>。我们需要将客户端和服务器之间交互的复杂性降到最低。保持协议和API契约简单是至关重要的。</p><p id="3a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则有几个好处。</p><p id="85eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，该服务有一个后端实现，但它被许多客户端库使用。通过减少客户端的逻辑数量，我们可以节省大量的工程时间。</p><p id="11e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二，服务器通常更了解故障的起源。它们可以为客户提供更好的指导，减少将系统恢复到正常工作状态的时间。</p><p id="dcdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，对复杂的网络交互进行故障排除非常困难。用一个简单的接口将该逻辑封装到一个组件中，使得客户端和服务器维护人员的调试更加容易。</p><h1 id="b999" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">2.考虑处理程序的设计错误</h1><p id="06e3" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">大多数错误都出现在遇到故障的层中。有一个扩展StandardException的类，一个处理边缘情况的if条件，或者一个throw语句。单元测试通过。任务完成。</p><p id="39e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is lu">开发人员忘记了必须有人来处理这个错误。</strong></p><p id="7346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须在设计错误时考虑到它们的接收者。然而，确定适当的抽象来处理它们是困难的。</p><p id="7118" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哪些组件关心错误？他们是直接接收还是通过其他层接收？他们会补救失败还是升级失败？应用程序会向最终用户显示错误吗？怎么会？</p><p id="708e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">找到并回答这些问题是困难的，但从长远来看，这对每个人都有好处。</p><h1 id="cabb" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">3.抽象应该减少错误率</h1><p id="5e65" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">好的抽象使系统更简单。我们没有封装组件来使最终的接口更难理解。至少我们尽量不这么做。</p><p id="dee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现错误率是判断抽象价值的一个重要指标。最好的抽象不会产生错误，但是分布式系统不能那样操作。</p><p id="64a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于单个错误类别，比率可以:</p><ol class=""><li id="80fa" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated">通过过滤误差来减少</li><li id="948f" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">通过进一步传递所有错误，保持在同一水平</li><li id="5bf5" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">通过放大误差来增加</li></ol><p id="76b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">降低错误率的抽象是有用的。</p><p id="5779" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is lu">提高错误率的抽象表示有问题。</strong></p><p id="1c3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些抽象根本不处理错误，这也没什么。例如，在格式之间转换值——假设映射不会失败——不会改变错误率，但仍然有用。</p><h1 id="1f66" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">4.早期故障，故障安全</h1><p id="2c87" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">对Pusher的每个请求都要经过我们堆栈的几层。首先，它攻击外部负载平衡器，然后是内部代理、服务本身，最终变成数据库操作。</p><p id="217d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在设计良好的系统中，每个抽象层都可以更深入地挖掘请求。边缘代理，如AWS ELB，工作在TCP层——它们不理解HTTP，WebSockets，更不用说服务逻辑了。我们的中间代理使用HTTP，但是它们不关心服务逻辑。</p><p id="62a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽象层也可能引入新的副作用。当请求在到达内部代理之前失败时，我们知道它没有触及服务的数据库。相反，当服务在接受请求和返回响应之间消失时，我们不能保证服务没有修改它的数据库。</p><p id="560c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is lu">尽早终止请求很重要，这样可以防止请求导致不一致和产生处理成本。每个错误应该来自最外层，它有足够的上下文来处理失败。例如，TCP负载平衡器不能限制请求速率，因为它们不理解HTTP。然而，我们的内部代理支持HTTP并知道适当的速率限制，因此它们可以限制处理的请求数量。</strong></p><p id="2f9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法增加了安全重试请求的数量，让客户端在不牺牲数据一致性的情况下进行恢复。</p><h1 id="8823" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">5.提供可操作的错误细节</h1><p id="9f12" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">老实说，我们不能处理所有的错误。有时无效数据会通过SDK。有时，如果没有人工干预，客户将无法解决不一致的问题。</p><p id="050a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些情况下，<strong class="is lu">提供足够的关于错误条件</strong>的人类可读细节是很重要的。仅仅有类名是不够的。人们需要错误类型、描述、参数，或者更好的解决问题的步骤。</p><p id="ca4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is lu">这些细节必须是可操作的。</strong>如果用户提交了无效的数据，服务应该提供纠正它的步骤。如果请求格式不正确，错误消息应该指出这很可能是客户端库的错误，开发人员应该向维护人员报告。</p><p id="8771" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，<strong class="is lu">避免不必要的细节至关重要。</strong>如果我们的数据库关闭，用户只能稍后重试请求。他们不应该知道内部服务与其数据库之间存在连接故障。他们需要知道错误是暂时的。</p><p id="6fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要设计协议、API、SDK和其他工具来始终提供这些信息。在这方面的失败意味着开发人员会将问题升级到支持，甚至会因为失望而放弃服务。</p><h1 id="088c" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">爱你的错误</h1><p id="e210" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">理论上，错误几乎不存在。事实上，他们可以像定义实际功能一样定义开发者体验。</p><p id="e686" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面概述的五个原则定义了Pusher的错误哲学，但它们符合我们为实时平台设计所有功能的方法:</p><ul class=""><li id="2a1a" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn lv kj kk kl bi translated">我们为客户的简单性而优化。</li><li id="ef98" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lv kj kk kl bi translated">我们在设计功能时考虑到了最终用户。</li><li id="a2cd" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lv kj kk kl bi translated">我们添加抽象来减少下游的工作量。</li><li id="497b" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lv kj kk kl bi translated">我们试图尽早处理业务逻辑。</li><li id="a298" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lv kj kk kl bi translated">我们还为功能提供可操作的文档。</li></ul><p id="5672" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">API应该为他们的用户服务。即使它们不起作用。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lw"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="48f8" class="mb ks hi bd kt mc md me kx mf mg mh lb jb mi mj lf jf mk ml lj jj mm mn ln mo bi translated">这篇文章发表在<a class="ae mp" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，有333，853+人关注。</h2><h2 id="24b8" class="mb ks hi bd kt mc md me kx mf mg mh lb jb mi mj lf jf mk ml lj jj mm mn ln mo bi translated">订阅接收<a class="ae mp" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lw"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>