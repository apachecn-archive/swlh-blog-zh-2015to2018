# iOS 设计模式—第 1 部分(MVC、MVP、MVVM)

> 原文：<https://medium.com/swlh/ios-design-patterns-a9bd07818129>

设计模式总是有助于构建可管理、可测试、可重用和优化的软件。一般来说，它有助于软件的模块化，这样每个组件都是独立的，处理单一的职责。此外，它们极大地提高了代码的可读性，这在软件代码的交流中起着重要的作用。此外，软件开发过程大大加快了已经证明的设计范例。移动开发人员无法远离遵循设计模式的好处。最初，移动应用程序太小，无法遵循设计或架构模式，因此它们过去总是严格遵循最基本的模式。如今，由于移动应用程序变得越来越大，并且几乎是它们桌面或 web 对应部分的镜像(功能方面),因此它们必须在实际进入开发模式之前考虑设计模式。

最近，我很奇怪地参加了 iOS 和 Swift dev 会议，或者亲自参加，或者在网上参加。每隔一次这样的会议至少有两到三次关于新兴的或公认的设计模式的讨论，特别是考虑到移动应用。像 iOS 这样的移动平台已经建议开发者在他们的应用中遵循 MVC(模型-视图-控制器)。苹果的 MVC 是原始 MVC 的修改版本，以适应移动应用程序，但开发人员社区却不这么认为。因此，开发者社区一直在尝试不同的设计模式，这些模式已经在其他软件开发平台中得到实践。我们将会看到这种被社区广泛接受的设计模式，这种转变也相当成功。像所有其他设计模式一样，这些模式也不会在所有情况下都适用。每个都有一些优点和缺点，我们完全有责任明智地选择其中一个。如果没有适合你的，开发者可以根据你的需要帮你生成一个新的。

我们将讨论 iOS 开发者社区中一些最流行的，MVC，MVP，MVVM 和 VIPER。这篇文章将由两部分组成。

# 模型-视图-控制器

先说最简单的，用的最多的。苹果通过它的样本代码，一直推荐遵循 MVC。如前所述，苹果形式的 MVC 被修改了一点，以更好地适应移动应用程序。其一般形式表示如下-

![](img/13a459e6af169dc4dc0331ecdfdef889.png)

Apple’s MVC representation

它基本上由一个视图、一个控制器和一个模型组成。视图可以被想象成在某个特定时间点向用户显示的用户界面。模型是要在视图组件中显示的数据。控制器是它们之间的桥梁。这三个，一直保持一种关系。控制器拥有一个视图，并将一个模型与它相关联。

视图有责任向用户显示它的用户界面。最终，视图将源自用户界面的动作传递给控制器。这些动作或者是用户发起的，例如，用户可以点击屏幕上的按钮来发起动作，或者有时是自动生成的，例如，屏幕可能需要及时刷新其内容。控制器的职责主要是从视图中接收这些动作，并对它们进行操作。控制器在处理时可以更新模型。有时这个更新过程需要一段时间。模型在完成更新过程时通知控制器，控制器通知视图用更新的数据更新它的用户界面。视图和模型从不直接对话。他们通过控制器交流。这是苹果的 MVC 与最初的 MVC 唯一的区别，如下所示。

![](img/7c2989cac0c051a554405161b6090254.png)

Original MVC representation

Apple 可能认为不要将视图与模型紧密绑定，因为移动应用程序中的视图可以高度重用。如果保持紧密耦合，我们将需要每次为不同的模型重新实现视图。独立于模型的视图是苹果 MVC 背后的真实想法。

很简单，对吧？但是 MVC 的简单性带来了一些问题和困难。这些问题直到移动应用程序变得更短更简单时才被正视。但现在，当 iOS 设备比台式机更强大时，用户希望移动应用程序足够强大，能够充分利用设备资源。更多的期望导致更大的应用程序，它通常集成多个组件，这反过来又导致更大的代码库。如果每个组件都被赋予有限的职责，那么这种包含多个组件的更大的代码库可以被很好地管理。

首先，MVC 导致的问题是，它没有遵循单一责任范式，结果导致了 MVC。什么？MVC 导致 MVC？是的，MVC(模型-视图-控制器)导致 MVC(海量视图控制器)。根据 MVC，控制器是视图和模型之间的中介。这迫使管制员处理许多责任。现代用户界面的设计方式是单个屏幕提供应用程序的某些功能。单个屏幕(视图)由多个功能子视图组成，屏幕控制器需要集成几个不同的复杂模块。管理多个功能子视图并与不同的模块集成是控制器的主要职责。在这种情况下，控制器将管理视图的生命周期，处理用户操作，在基于客户机-服务器的应用程序中，可能需要进行服务器调用，处理响应，处理错误，运行屏幕刷新计时器，处理多个回调，监听通知，处理视图的方向等等。这使得控制器的代码更大。显然，代码变得很难管理和理解。当 iOS 中引入子控制器的概念时，这个问题稍微得到了解决。

其次，MVC 使得测试单元测试用例变得困难。由于控制器-视图的直接关系，开发人员需要以这样一种方式进行调整和试验，即只执行业务逻辑来生成有效的测试用例结果。

MVC 在许多用户界面更简单、控制器需要处理的责任更少的情况下仍然工作得很好，但是对于复杂的用户界面，它却很糟糕。

# 模型-视图-演示者

![](img/08841d9e3121445a1128e42371fefdc9.png)

MVP 只是苹果 MVC 的扩展，视图控制器的职责在视图和演示者之间分配。它将控制器视为一个视图。视图保持 UI 处理责任，而 Presenter 处理实际的业务逻辑(更新模型和其他事情)。这样，单元测试就更容易了，因为所有的单元测试用例都是在视图相关的处理不可用的地方编写的。在某种程度上，它优于苹果的 MVC，它很好地分配了责任，测试单元测试用例也不那么繁琐。这降低了开发速度，因为跨层实现 Presenter 和绑定它会带来一些额外的工作。

# MVVM(模型-视图-视图模型)

这是在现代应用中引人注目的最新式样。它最初是由微软在 2005 年推出的，目的是使事件驱动编程更容易。移动开发者社区发现它对移动应用程序也有好处。它被证明适合 MVC 可能带来的大多数挑战。

![](img/eebb525a7d51c7eaf2a47b1d04b321e1.png)

MVVM 要求将责任分配给视图(视图/视图控制器)、模型和视图模型。像 MVP 一样，MVVM 也将视图控制器视为视图的一部分。我们已经从 MVP 模式中知道了视图和模型的职责。ViewModel 是这里的新组件，负责与 UI 无关的处理。在责任分担方面，它看起来像 MVP 中的演示者。在 MVP 中，视图特定的数据创建逻辑与视图保持一致。呈现者只是充当视图和模型之间的中介，并与视图控制器分担一些责任。由于分配不当，视图控制器仍然需要处理 MVP 中的大量职责。然而在 MVVM，顾名思义，视图模型是模型的视图特定表示。视图拥有视图模型，视图模型又拥有模型。因此，MVVM 的一个典型流程是，视图从服务器或数据库获取数据，并将其提供给视图模型。视图模型然后处理它，并通过绑定通知回来。视图模型数据处理的一个小例子是，一个模型可能有一个以毫秒为单位的时间戳，但是视图希望以用户友好的方式来表示它。在这种情况下，视图模型负责将时间戳(毫秒)转换为格式化的日期字符串。然后视图使用这个格式化的日期字符串向用户显示。视图模型保持了表示数据创建的复杂性，从而减少了视图(控制器)的责任。

视图模型通过绑定与视图共享更新。如果我们谈论在 iOS 中实现绑定，没有原生的方法。我们仍然可以通过 KVO、委托或通知来实现类似的机制。这并不像其他编程语言中的绑定那样有效。为了有效地实现绑定，开发人员已经开始用反应式方法(比通过 KVO 或通知实现绑定更好的方法)链接 MVVM。MVVM 有助于分配职责，而反应式方法有助于将视图模型与视图绑定在一起。

尽管视图模型与视图紧密耦合，我们还是设法将视图和模型分开，这是苹果的 MVC 高度要求的。此外，业务逻辑(由视图模型处理)与视图控制器的分离使得单元测试变得容易。

MVVM 确实有自己的挑战。它从很高的层次解释了责任的分配。由于移动应用并没有被放在心上，所以移动开发者对什么给谁谈了很多。一个这样的辩论将讨论与网络相关的代码属于哪里？查看还是查看模型？原来 MVVM 说它应该属于视图。在我看来，这是有意义的，因为视图可以直接处理错误场景，允许视图向用户显示错误或重试操作。如果一个视图模型想要保留网络代码，使其从视图中抽象出来，它需要用错误响应视图，在这种情况下，就增加了额外的抽象层。最后，它的开发人员根据他们的需要来决定和分配职责。

开发人员面临的另一个挑战是反应式方法非常复杂。它确实有一个学习曲线，并且容易出错，开发人员可能很难发现问题。

这在理论上似乎是一个非常好的架构模式，在实际场景中也能很好地工作。对于简单的用户界面来说，这不是最好的选择。

我希望这篇文章对你有用。在这篇博文的最后一部分，我将介绍 VIPER 设计模式。

![](img/731acf26f5d44fdc58d99a6388fe935d.png)

## 这篇文章发表在 [The Startup](https://medium.com/swlh) 上，这是 Medium 最大的创业刊物，有 277，994+人关注。

## 订阅接收[我们的头条新闻](http://growthsupply.com/the-startup-newsletter/)。

![](img/731acf26f5d44fdc58d99a6388fe935d.png)