<html>
<head>
<title>What are the cons to adding a lot of fragment caching to my Rails app?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在我的Rails应用中添加大量的片段缓存有什么坏处？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/what-are-the-cons-to-adding-a-lot-of-fragment-caching-to-my-rails-app-5f37d86da111#2017-07-09">https://medium.com/swlh/what-are-the-cons-to-adding-a-lot-of-fragment-caching-to-my-rails-app-5f37d86da111#2017-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fe7c366df6321c1e4117a7ebca32bc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF5Cvk5LXh5PwABQqpXJEg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">What are the cons to adding a lot of fragment caching to my Rails app?</figcaption></figure><p id="8aa2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated"><span class="l jt ju jv bm jw jx jy jz ka di"> W </span> hy缓存？简而言之，缓存可以加快Rails应用程序的速度。尤其是对于Ruby这种速度不是很快的语言，缓存是必不可少的。您的开发人员可能经常听到“缓存”这个词，它碰巧是一个法语单词，翻译过来的意思是“隐藏”缓存是将请求-响应周期中生成的特定数量的数据存储在缓存中，并在响应类似请求时重用它。这意味着您的用户在未来提出的请求会得到更快的满足，因为不需要再次生成完全相同的数据。几乎所有重视性能的Rails应用程序都可以使用更多的缓存。不过，这种缓存必须智能地完成，以实现快速的服务器响应时间。</p><p id="6b2c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">缓存有很多好处，因为它可以有效地加速应用程序并改善用户体验。多亏了缓存，即使你的网站运行在只有一个数据库的单个服务器上，它也能支持成千上万的并发用户。缓存将减少数据访问时间，减少延迟，并改善输入/输出。Rails附带了各种缓存技术:页面、动作、片段、模型和HTTP缓存。您的开发人员最有可能将多种技术结合在一起使用。</p><p id="b323" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个优秀的开发人员，如果掌握了各种缓存技术，并且知道何时何地利用这些技术，就可以确保Rails应用程序服务于数百万的视图，而不会有过高的响应时间或服务器开销。大多数开发人员没有给予这种关注，因为总是有新的特性要添加，或者下一个用户故事。这种债务将开始增加，最终，只有当整个事情都崩溃时，性能才是最重要的。更糟糕的是，缓存并不总是容易的，最佳缓存实践似乎每隔一周就在变化。在Rails应用程序中，即使没有缓存，每个请求300毫秒也不是闻所未闻，主要是如果您一直在努力使用ActiveRecord和SQL查询的话。即便如此，当您使用缓存时，还是容易得多。</p><h1 id="c914" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Rails中的缓存</h1><p id="e3da" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">Rails缓存存储除缓存页面之外的所有缓存内容。缓存的页面最终以HTML的形式存储在磁盘上。此外，您的rails应用程序提供的不仅仅是片段缓存。</p><ul class=""><li id="334f" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">页面缓存:这背后的想法非常简单，整个HTML页面被保存到公共目录中的一个文件中，在后续的请求中，这个文件被直接发送给用户，而不需要再次呈现视图和布局。不过这只适用于简单的应用程序。很有可能，你有很多页面对于不同的用户来说看起来是不同的。因此，页面缓存并不是您的最佳选择。然而，它在半静态页面上大放异彩。Rails现在只能通过单独的gem来访问它。</li><li id="1b10" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">动作缓存:它的工作方式很像页面缓存，但是它不是立即发送存储在公共目录中的页面，而是攻击Rails堆栈。通过这样做，它在可以处理认证逻辑的动作之前运行。动作缓存现在也可以作为一个单独的gem使用。</li><li id="5c1d" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">片段缓存:现在片段缓存是指你只想缓存页面的一部分，而不是整个页面。换句话说，当您想要在缓存中存储部分视图时。</li><li id="d3c9" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">模型缓存:也称为低级缓存，用于缓存特定的查询。尽管如此，这种方法可以用来存储任何数据。这个功能是Rails核心的一部分。</li><li id="bc02" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">HTTP缓存:这依赖于HTTP头。这些头是由客户端发送的，用于查看页面内容最后一次修改的时间，以及它的惟一id是否已经更改。</li></ul><p id="2273" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，初步优化是万恶之源，所以您的开发人员应该在实现之前评估哪种缓存方法最适合您。</p><h1 id="7fc0" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">片段缓存</h1><p id="71f4" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">顾名思义，片段缓存只缓存页面的一部分。这是一个存在于你的Rails核心中的功能，所以你的开发者不必手动添加它。片段缓存让视图逻辑的片段被封装在一个缓存块中，当下一个请求进来时，它由缓存存储提供。动态web应用程序倾向于构建带有各种组件的页面，并且并非所有组件都具有相同的缓存特性。当页面的不同部分需要分别缓存和过期时，片段缓存是理想的。</p><p id="5bde" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你是新手，忽略动作缓存和页面缓存。这两种技术被证明有用的情况很少，事实上，从4.0开始，这些特性已经从Rails中删除了。我建议改用片段缓存。片段缓存比整页缓存有用得多，尤其是在复杂的应用程序中。在缓存整个页面效率不高的情况下，它们通常由较小的组件构建。缓存整个页面意味着，对站点特定部分的单个更改将需要重新呈现整个页面并再次存储。这意味着缓存的优势将很快变得没有实际意义。更明智的做法是瞄准较小的位。</p><h1 id="207f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">添加大量片段缓存的缺点</h1><p id="e8a1" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">这就是侧写的用武之地。与其冒险猜测应用程序的哪些区域是性能热点，不如启动一个分析工具来告诉您页面的哪些片段运行缓慢。利用rack-mini-profiler，在特定的服务器响应过程中，它会给你一个很好的细分，告诉你所有的时间都去了哪里。剖析将防止您过度缓存页面，而是针对正确的片段。</p><ul class=""><li id="cbcb" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">虽然缓存对你的应用有好处。好事过犹不及。过多的缓存会导致大量的数据堆积，这反过来会在更新数据库时导致问题。</li><li id="a2e3" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">这可能会导致更新数据的困难，尤其是当您有数百个用户缓存，并试图在更新时找出哪个缓存是谁的时。</li><li id="c50a" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">如果你经常使用Memcached，你的Rails应用程序会在超过内存限制时开始变慢，因为你把所有东西(缓存)都存储在内存中。</li><li id="2979" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">不要走得太远。对Memcached的请求不是免费的。你可以通过缓存少量的大片段而不是大量的小片段来最大化优势。</li></ul><h1 id="b8ba" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论:</h1><blockquote class="ls"><p id="bc7e" class="lt lu hi hj lv lw lx ly lz ma mb jr dx translated">通过网络获取任何东西既慢又贵。重用和缓存以前获取的数据的能力是性能优化的重要部分。然而，要真正获得缓存的所有好处，必须明智地进行缓存，而不仅仅是习惯性的。</p></blockquote></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="daf7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="mj">最初发表于CognitiveClouds的产品洞察博客:Top </em> <a class="ae mk" href="https://www.cognitiveclouds.com/custom-software-development-services/ruby-on-rails-development-company" rel="noopener ugc nofollow" target="_blank"> <strong class="iw ml"> <em class="mj"> Ruby on Rails开发公司</em> </strong> </a></p><figure class="mn mo mp mq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="mr kc hi bd kd ms mt mu kh mv mw mx kl jf my mz kp jj na nb kt jn nc nd kx ne bi translated">这篇文章发表在<a class="ae mk" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有299，352+读者。</h2><h2 id="7945" class="mr kc hi bd kd ms mt mu kh mv mw mx kl jf my mz kp jj na nb kt jn nc nd kx ne bi translated">在这里订阅接收<a class="ae mk" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="mn mo mp mq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>