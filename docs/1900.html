<html>
<head>
<title>Fibonacci Swift playground</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斐波那契斯威夫特游乐场</h1>
<blockquote>原文：<a href="https://medium.com/swlh/fibonacci-swift-playground-f56d1ff3ea99#2018-01-06">https://medium.com/swlh/fibonacci-swift-playground-f56d1ff3ea99#2018-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/59cbfe0e3878b520203f7ed01467ac86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32QmDBSjVMdChC7pM58oEg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Golden Ratio: two quantities are in the <a class="ae hv" href="https://en.wikipedia.org/wiki/Golden_ratio" rel="noopener ugc nofollow" target="_blank"><strong class="bd hw">golden ratio</strong></a> if their ratio is the same as the ratio of their sum to the larger of the two quantities</figcaption></figure><div class=""/><p id="8c3f" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">假设你站在一个有<code class="du ju jv jw jx b">n</code>级楼梯的楼梯前。你可以一次走一两级楼梯。你能达到顶峰的不同方法总共有多少种？</p><p id="e7ab" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果我们知道到达<code class="du ju jv jw jx b">n-1</code>和<code class="du ju jv jw jx b">n-2</code>的路径数，那么到达点<code class="du ju jv jw jx b">n</code>的总路径就是这两个值的和。这实际上与计算斐波纳契数列的第<code class="du ju jv jw jx b">n</code>个数字是一样的。在这里，我试图提出不同的方法来解决斐波那契问题，其中包括算法比较，以及围绕时间和空间复杂性的讨论。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="8a51" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">递归方法</h2><p id="aa5b" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">我们可以从递归方法开始。假设我们已经知道所有以前的数字是什么，那么不言而喻，当前数字是最后两个数字的和(自上而下的方法)。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="ae8c" class="kf kg hz jx b fi lo lp l lq lr">func fib(_ n: Int) -&gt; Int {<br/>    guard n &gt; 1 else { return n }<br/>    return fib(n-1) + fib(n-2)<br/>}</span></pre><p id="dff3" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">时间复杂度:O(2^n) <br/>空间复杂度:O(2^n) </em></p><p id="aa11" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这种解决方案的问题是我们不断地重复计算同样的子问题。换句话说，我们的算法做了大量重复的工作。这个算法呈指数增长，特别是当<code class="du ju jv jw jx b">n</code>很大的时候，它需要很大的努力。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/b982aec3cc09683032560801d36afa65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tNzBsD415roh9K_scjF7A@2x.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion tree for fib(4)</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="887a" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">迭代方法</h2><p id="ef3f" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">这种方法来源于相同的想法，但稍有改动。如果我们将所有的值存储在一个数组中以备将来使用，我们就避免了冗余工作。每当再次调用该函数时，该函数直接返回来自<em class="lf"> memo </em>数组的结果。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="f8b8" class="kf kg hz jx b fi lo lp l lq lr">func fib(_ n: Int) -&gt; Int {<br/>    var fibs: [Int] = [1, 1]<br/>    (2...n).forEach { i in <br/>        fibs.append(fibs[i - 1] + fibs[i - 2]) <br/>    }<br/>    return fibs.last!<br/>}</span></pre><p id="c72c" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">时间复杂度:O(n) <br/>空间复杂度:O(n) </em></p><p id="9c47" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">通过对算法的小小改动，我们做了巨大的优化。举例来说，<code class="du ju jv jw jx b">n = 45</code>需要90步(而我们的递归方法需要10亿步)，大约快了1000万倍。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="32e2" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">迭代方法—优化</h2><p id="bd9a" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">我们不需要存储整个数组。我们只需要最后两个值:</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="b1e0" class="kf kg hz jx b fi lo lp l lq lr">func fib(_ n: Int) -&gt; Int {<br/>    var a = 1<br/>    var b = 1<br/>    guard n &gt; 1 else { return a }<br/>    <br/>    (2...n).forEach { _ in <br/>        (a, b) = (a + b, a) <br/>    }<br/>    return a<br/>}</span></pre><p id="538f" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">时间复杂度:O(n) <br/>空间复杂度:O(1) </em></p><p id="38d3" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在<em class="lf"> for循环中，</em>我们给<code class="du ju jv jw jx b">a</code>和<code class="du ju jv jw jx b">b</code>赋值(元组的美丽)。如果你注意到等式<code class="du ju jv jw jx b">(a, b) = (a + b, a)</code>是黄金比例的精确定义。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="5d96" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">矩阵方法的力量</h2><p id="92de" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">让我们假设矩阵<code class="du ju jv jw jx b">M</code>为:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/28d31c3f98d0463eafe39527304d51f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*uLVwGZivR-PCSNJUqUtVPw@2x.png"/></div></figure><p id="a5c2" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了得到第<code class="du ju jv jw jx b">n</code>个斐波那契数，矩阵M必须乘以自身的<code class="du ju jv jw jx b">n-1</code>倍，并形成<code class="du ju jv jw jx b">n-1</code>次方:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/41c53ca4982cd4f12a13892bd415048c.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*rRhyyTvbOJOou3aAfG_cDw@2x.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Fibonacci closed-form expression, <em class="lv">Binet</em>’s formula</figcaption></figure><p id="5762" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">假设我们有一个很棒的方法<code class="du ju jv jw jx b">multiply</code>，它将两个矩阵相乘并返回一个结果矩阵，算法就像这样简单:</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="583c" class="kf kg hz jx b fi lo lp l lq lr">func fib(_ n: Int) -&gt; Int {<br/>    guard n &gt; 2 else { return n }<br/>    <br/>    let M = [[1, 1], [1, 0]]<br/>    var result: [[Int]] = M<br/>    (1..&lt;n).forEach { _ in result = multiply(result, M) }<br/>    return result[0][0]<br/>}</span></pre><p id="5073" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">时间复杂度:O(n) <br/>空间复杂度:O(1) </em></p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="3409" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">矩阵方法的威力—优化</h2><p id="791e" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">为了形成矩阵<code class="du ju jv jw jx b">M</code>的<code class="du ju jv jw jx b">n</code>次方，我们不需要将它乘以自身的<code class="du ju jv jw jx b">n</code>倍。想法是这样的，假设你想计算5⁸，最简单的方法是将5乘以8。更好的方法是重复平方并加倍指数:<br/>5 = 25<br/>25 =5⁴= 625<br/>625 =5⁸= 390，625</p><p id="4e12" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">正如你所看到的，这个<a class="ae hv" href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring" rel="noopener ugc nofollow" target="_blank">平方方法</a>比原始方法使用了更少的乘法(三对八，换句话说，减少对数)。同样的想法也适用于矩阵:</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="a611" class="kf kg hz jx b fi lo lp l lq lr">func fib(_ n: Int) -&gt; Int {<br/>    var M = [[1, 1], [1, 0]]<br/>    guard n &gt; 2 else { return n }<br/>    power(&amp;M, n)<br/>    return M[0][0]<br/>}</span><span id="e3af" class="kf kg hz jx b fi lw lp l lq lr">func power(_ matrix: inout [[Int]], _ n: Int) {<br/>    guard n &gt; 1 else { return }<br/>    power(&amp;matrix, n/2)<br/>    matrix = multiply(matrix, matrix)<br/>    if n % 2 != 0 {<br/>        let M = [[1, 1], [1, 0]]<br/>        matrix = multiply(matrix, M)<br/>    }<br/>}</span></pre><p id="42d1" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">时间复杂度:O(log n) <br/>空间复杂度:O(log n)，因为递归栈</em></p><p id="8004" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在上面的代码片段中，<code class="du ju jv jw jx b">power</code>函数试图通过平方<code class="du ju jv jw jx b">(n/2)</code>的次方来计算<code class="du ju jv jw jx b">M</code>的<code class="du ju jv jw jx b">n</code>次方。然而，如果n是奇数，向下舍入<code class="du ju jv jw jx b">n/2</code>并平方<code class="du ju jv jw jx b">M</code>的幂得到<code class="du ju jv jw jx b">(n-1)</code>的幂，再乘以<code class="du ju jv jw jx b">M</code>的一个因子将构成该单个因子。这肯定是我们可以用来得到第<code class="du ju jv jw jx b">n</code>个斐波那契数的最快和最优化的算法。</p><p id="bbbe" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">你可能会问<code class="du ju jv jw jx b">inout</code>关键字或<code class="du ju jv jw jx b">&amp;</code>符号，这些在我们的算法中并没有真正发挥任何重要作用。为了提高性能，他们只是让我们通过递归堆栈传递矩阵引用。如果您有兴趣了解更多信息，请查看Swift 中的<a class="ae hv" rel="noopener" href="/@m.tabrizi/value-types-vs-reference-types-in-swift-87568a56e0e2">值类型与引用类型。</a></p><p id="113b" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你有任何建议，请让我知道，并随时留下您的评论。你可以在这里找到这篇文章的所有代码。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="d6a3" class="lx kg hz bd kh ly lz ma kl mb mc md kp me mf mg ks mh mi mj kv mk ml mm ky mn bi translated">进一步研究:</h1><p id="4797" class="pw-post-body-paragraph iw ix hz iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated"><a class="ae hv" href="https://www.ics.uci.edu/~eppstein/161/960109.html" rel="noopener ugc nofollow" target="_blank">斐波那契数列</a> <br/> <a class="ae hv" href="https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/" rel="noopener ugc nofollow" target="_blank">斐波那契数列程序— GeeksforGeeks </a> <br/> <a class="ae hv" href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibpuzzles.html" rel="noopener ugc nofollow" target="_blank">更简单的斐波那契拼图</a></p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="9802" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lf">这篇文章是写给亚历克斯·斯米尔诺夫的，他总是激励人心</em></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">这篇文章发表在<a class="ae hv" href="https://medium.com/swlh" rel="noopener">《创业</a>》上，这是Medium最大的创业刊物，有281，454+人关注。</h2><h2 id="7945" class="kf kg hz bd kh ki kj kk kl km kn ko kp jh kq kr ks jl kt ku kv jp kw kx ky kz bi translated">订阅接收<a class="ae hv" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>