<html>
<head>
<title>iOS design patterns — Part 1 (MVC, MVP, MVVM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS设计模式—第1部分(MVC、MVP、MVVM)</h1>
<blockquote>原文：<a href="https://medium.com/swlh/ios-design-patterns-a9bd07818129#2017-11-27">https://medium.com/swlh/ios-design-patterns-a9bd07818129#2017-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式总是有助于构建可管理、可测试、可重用和优化的软件。一般来说，它有助于软件的模块化，这样每个组件都是独立的，处理单一的职责。此外，它们极大地提高了代码的可读性，这在软件代码的交流中起着重要的作用。此外，软件开发过程大大加快了已经证明的设计范例。移动开发人员无法远离遵循设计模式的好处。最初，移动应用程序太小，无法遵循设计或架构模式，因此它们过去总是严格遵循最基本的模式。如今，由于移动应用程序变得越来越大，并且几乎是它们桌面或web对应部分的镜像(功能方面),因此它们必须在实际进入开发模式之前考虑设计模式。</p><p id="c8a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我很奇怪地参加了iOS和Swift dev会议，或者亲自参加，或者在网上参加。每隔一次这样的会议至少有两到三次关于新兴的或公认的设计模式的讨论，特别是考虑到移动应用。像iOS这样的移动平台已经建议开发者在他们的应用中遵循MVC(模型-视图-控制器)。苹果的MVC是原始MVC的修改版本，以适应移动应用程序，但开发人员社区却不这么认为。因此，开发者社区一直在尝试不同的设计模式，这些模式已经在其他软件开发平台中得到实践。我们将会看到这种被社区广泛接受的设计模式，这种转变也相当成功。像所有其他设计模式一样，这些模式也不会在所有情况下都适用。每个都有一些优点和缺点，我们完全有责任明智地选择其中一个。如果没有适合你的，开发者可以根据你的需要帮你生成一个新的。</p><p id="3930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将讨论iOS开发者社区中一些最流行的，MVC，MVP，MVVM和VIPER。这篇文章将由两部分组成。</p><h1 id="0205" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">模型-视图-控制器</h1><p id="2226" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">先说最简单的，用的最多的。苹果通过它的样本代码，一直推荐遵循MVC。如前所述，苹果形式的MVC被修改了一点，以更好地适应移动应用程序。其一般形式表示如下-</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/13a459e6af169dc4dc0331ecdfdef889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EDf9kU5lyIewgAoV.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Apple’s MVC representation</figcaption></figure><p id="bcb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它基本上由一个视图、一个控制器和一个模型组成。视图可以被想象成在某个特定时间点向用户显示的用户界面。模型是要在视图组件中显示的数据。控制器是它们之间的桥梁。这三个，一直保持一种关系。控制器拥有一个视图，并将一个模型与它相关联。</p><p id="2e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">视图有责任向用户显示它的用户界面。最终，视图将源自用户界面的动作传递给控制器。这些动作或者是用户发起的，例如，用户可以点击屏幕上的按钮来发起动作，或者有时是自动生成的，例如，屏幕可能需要及时刷新其内容。控制器的职责主要是从视图中接收这些动作，并对它们进行操作。控制器在处理时可以更新模型。有时这个更新过程需要一段时间。模型在完成更新过程时通知控制器，控制器通知视图用更新的数据更新它的用户界面。视图和模型从不直接对话。他们通过控制器交流。这是苹果的MVC与最初的MVC唯一的区别，如下所示。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kx"><img src="../Images/7c2989cac0c051a554405161b6090254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DOEDR5YbP0DP-3t4.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Original MVC representation</figcaption></figure><p id="afe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Apple可能认为不要将视图与模型紧密绑定，因为移动应用程序中的视图可以高度重用。如果保持紧密耦合，我们将需要每次为不同的模型重新实现视图。独立于模型的视图是苹果MVC背后的真实想法。</p><p id="4723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单，对吧？但是MVC的简单性带来了一些问题和困难。这些问题直到移动应用程序变得更短更简单时才被正视。但现在，当iOS设备比台式机更强大时，用户希望移动应用程序足够强大，能够充分利用设备资源。更多的期望导致更大的应用程序，它通常集成多个组件，这反过来又导致更大的代码库。如果每个组件都被赋予有限的职责，那么这种包含多个组件的更大的代码库可以被很好地管理。</p><p id="4915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，MVC导致的问题是，它没有遵循单一责任范式，结果导致了MVC。什么？MVC导致MVC？是的，MVC(模型-视图-控制器)导致MVC(海量视图控制器)。根据MVC，控制器是视图和模型之间的中介。这迫使管制员处理许多责任。现代用户界面的设计方式是单个屏幕提供应用程序的某些功能。单个屏幕(视图)由多个功能子视图组成，屏幕控制器需要集成几个不同的复杂模块。管理多个功能子视图并与不同的模块集成是控制器的主要职责。在这种情况下，控制器将管理视图的生命周期，处理用户操作，在基于客户机-服务器的应用程序中，可能需要进行服务器调用，处理响应，处理错误，运行屏幕刷新计时器，处理多个回调，监听通知，处理视图的方向等等。这使得控制器的代码更大。显然，代码变得很难管理和理解。当iOS中引入子控制器的概念时，这个问题稍微得到了解决。</p><p id="7bbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，MVC使得测试单元测试用例变得困难。由于控制器-视图的直接关系，开发人员需要以这样一种方式进行调整和试验，即只执行业务逻辑来生成有效的测试用例结果。</p><p id="6c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MVC在许多用户界面更简单、控制器需要处理的责任更少的情况下仍然工作得很好，但是对于复杂的用户界面，它却很糟糕。</p><h1 id="d520" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">模型-视图-演示者</h1><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ky"><img src="../Images/08841d9e3121445a1128e42371fefdc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ORSOVw0IB8vgBT_7.png"/></div></div></figure><p id="9061" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MVP只是苹果MVC的扩展，视图控制器的职责在视图和演示者之间分配。它将控制器视为一个视图。视图保持UI处理责任，而Presenter处理实际的业务逻辑(更新模型和其他事情)。这样，单元测试就更容易了，因为所有的单元测试用例都是在视图相关的处理不可用的地方编写的。在某种程度上，它优于苹果的MVC，它很好地分配了责任，测试单元测试用例也不那么繁琐。这降低了开发速度，因为跨层实现Presenter和绑定它会带来一些额外的工作。</p><h1 id="8db0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">MVVM(模型-视图-视图模型)</h1><p id="1b07" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是在现代应用中引人注目的最新式样。它最初是由微软在2005年推出的，目的是使事件驱动编程更容易。移动开发者社区发现它对移动应用程序也有好处。它被证明适合MVC可能带来的大多数挑战。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kz"><img src="../Images/eebb525a7d51c7eaf2a47b1d04b321e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lF2hQpgjPUp6kpF6.png"/></div></div></figure><p id="563e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MVVM要求将责任分配给视图(视图/视图控制器)、模型和视图模型。像MVP一样，MVVM也将视图控制器视为视图的一部分。我们已经从MVP模式中知道了视图和模型的职责。ViewModel是这里的新组件，负责与UI无关的处理。在责任分担方面，它看起来像MVP中的演示者。在MVP中，视图特定的数据创建逻辑与视图保持一致。呈现者只是充当视图和模型之间的中介，并与视图控制器分担一些责任。由于分配不当，视图控制器仍然需要处理MVP中的大量职责。然而在MVVM，顾名思义，视图模型是模型的视图特定表示。视图拥有视图模型，视图模型又拥有模型。因此，MVVM的一个典型流程是，视图从服务器或数据库获取数据，并将其提供给视图模型。视图模型然后处理它，并通过绑定通知回来。视图模型数据处理的一个小例子是，一个模型可能有一个以毫秒为单位的时间戳，但是视图希望以用户友好的方式来表示它。在这种情况下，视图模型负责将时间戳(毫秒)转换为格式化的日期字符串。然后视图使用这个格式化的日期字符串向用户显示。视图模型保持了表示数据创建的复杂性，从而减少了视图(控制器)的责任。</p><p id="0b30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">视图模型通过绑定与视图共享更新。如果我们谈论在iOS中实现绑定，没有原生的方法。我们仍然可以通过KVO、委托或通知来实现类似的机制。这并不像其他编程语言中的绑定那样有效。为了有效地实现绑定，开发人员已经开始用反应式方法(比通过KVO或通知实现绑定更好的方法)链接MVVM。MVVM有助于分配职责，而反应式方法有助于将视图模型与视图绑定在一起。</p><p id="616d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管视图模型与视图紧密耦合，我们还是设法将视图和模型分开，这是苹果的MVC高度要求的。此外，业务逻辑(由视图模型处理)与视图控制器的分离使得单元测试变得容易。</p><p id="214c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MVVM确实有自己的挑战。它从很高的层次解释了责任的分配。由于移动应用并没有被放在心上，所以移动开发者对什么给谁谈了很多。一个这样的辩论将讨论与网络相关的代码属于哪里？查看还是查看模型？原来MVVM说它应该属于视图。在我看来，这是有意义的，因为视图可以直接处理错误场景，允许视图向用户显示错误或重试操作。如果一个视图模型想要保留网络代码，使其从视图中抽象出来，它需要用错误响应视图，在这种情况下，就增加了额外的抽象层。最后，它的开发人员根据他们的需要来决定和分配职责。</p><p id="7960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发人员面临的另一个挑战是反应式方法非常复杂。它确实有一个学习曲线，并且容易出错，开发人员可能很难发现问题。</p><p id="409b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在理论上似乎是一个非常好的架构模式，在实际场景中也能很好地工作。对于简单的用户界面来说，这不是最好的选择。</p><p id="2be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章对你有用。在这篇博文的最后一部分，我将介绍VIPER设计模式。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es la"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="lb jf hi bd jg lc ld le jk lf lg lh jo iq li lj js iu lk ll jw iy lm ln ka lo bi translated">这篇文章发表在<a class="ae jd" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，有277，994+人关注。</h2><h2 id="7945" class="lb jf hi bd jg lc ld le jk lf lg lh jo iq li lj js iu lk ll jw iy lm ln ka lo bi translated">订阅接收<a class="ae jd" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es la"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>