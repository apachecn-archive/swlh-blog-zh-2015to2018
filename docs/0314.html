<html>
<head>
<title>Starting a tech startup with C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++启动科技创业</h1>
<blockquote>原文：<a href="https://medium.com/swlh/starting-a-tech-startup-with-c-6b5d5856e6de?source=collection_archive---------0-----------------------#2016-01-02">https://medium.com/swlh/starting-a-tech-startup-with-c-6b5d5856e6de?source=collection_archive---------0-----------------------#2016-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fb10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我和一位大学老朋友，林网络公司的费多尔·朱巴一起创办了一家名为“信号分析”的新科技公司。我们正在通过建立自己的数据库系统来构建一个现代的、基于云的<a class="ae jd" href="https://en.wikipedia.org/wiki/OLAP_cube" rel="noopener ugc nofollow" target="_blank"> OLAP </a>多维数据存储和检索(cubes)。</p><p id="8a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在技术方面处于领先地位，我对C++非常熟悉，所以决定用它来构建我们的OLAP引擎。我最初确实在Rust中构建了一个原型，但是风险太高了(我应该再写一篇文章来解释这个决定)。</p><p id="b044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的许多同行认为我用C++而不是用动态语言——比如Ruby或Python——构建云服务很奇怪，这种语言提供了高生产率以快速交付。</p><p id="5a1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它开始质疑我自己使用C++的判断，我决定研究它是否是一个好主意。</p><h2 id="fd6d" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">生产力</strong></h2><p id="b013" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">C++不是一种动态语言，但是现代C++ (C++11/14)有类型推理。有很多误解，认为如果用C++编写，就必须用原始指针编码，键入冗长的名称空间/类型，并手动管理内存。在C++中感觉更有效率的一个关键特性是<a class="ae jd" href="http://en.cppreference.com/w/cpp/language/auto" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> auto </em> </a>特性；您不必键入冗长的命名空间和类；它使用类型推断来推断变量的类型。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="6991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手动内存管理是对C++最普遍的误解。从C++11开始，现在推荐使用<a class="ae jd" href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noopener ugc nofollow" target="_blank"><em class="ke">STD::shared _ ptr</em></a>或<a class="ae jd" href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noopener ugc nofollow" target="_blank"><em class="ke">STD::unique _ ptr</em></a>进行自动内存管理。维护被引用的指针需要很少的计算成本，但这很小，安全性超过了这一成本。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="51e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高效的最后一个部分是拥有快速构建服务/产品的库。Python、Ruby和其他语言都有很好的库来处理公共基础设施。在我看来，当前的C++标准库严重缺乏基本功能，某些API的性能很差(例如，从iostreams读取文件)。脸书拥有开源的高质量库，帮助我们快速发布OLAP云服务的alphas版本。：</p><ul class=""><li id="1a6b" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated"><a class="ae jd" href="https://github.com/facebook/folly/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih kv"> <em class="ke">愚昧</em> </strong> </a></li></ul><p id="c2eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个很棒的通用C++库，有很多高性能的类可以使用。我在整个引擎中使用他们的<em class="ke"> fbvector，fbstring </em>，因为它分别比他们的std::vector和std::string提供了更好的性能。我们还使用了很多他们的未来和原子无锁数据结构。</p><p id="1129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脸书在他们的动态增长分配上做了一个非常聪明的举动，没有使用二次增长(这很容易从数学上证明为什么不好)。他们的容器将内存大小增加了1.5倍，而不是2倍，以提高性能。</p><p id="ec6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，阅读《愚蠢代码》也让我成为了一名更好的C++开发人员，所以我强烈推荐阅读这本书。</p><ul class=""><li id="8b50" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated"><a class="ae jd" href="https://github.com/facebook/proxygen" rel="noopener ugc nofollow" target="_blank"> <strong class="ih kv"> <em class="ke">比邻星</em> </strong> </a></li></ul><p id="2ffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Proxygen是一个异步HTTP服务器，也是由脸书开发的。我们使用Proxygen作为HTTP服务器，以JSON格式向OLAP引擎插入数据，并从中检索数据。它允许我们在一天内创建一个调用我们引擎的高性能HTTP服务器。我决定用Python Tornado服务器对它进行基准测试，并在EC2实例上用200个HTTP连接进行测试，得到了以下结果:</p><p id="f034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ke"> C++/Proxygen =每秒1，990，130个请求</em></p><p id="f291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ke"> Python/Tornado =每秒41，329个请求</em></p><p id="e2de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的API更低级，你必须编写自己的HTTP路由，但这是一个微不足道的任务。下面是我们的HTTP主体处理程序大致的样子:</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><ul class=""><li id="60cd" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated"><a class="ae jd" href="https://github.com/facebook/wangle" rel="noopener ugc nofollow" target="_blank"> <strong class="ih kv"> <em class="ke">王乐</em> </strong> </a></li></ul><p id="4512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的OLAP引擎本质上是一个分布式数据库，用于存储和查询多维数据。该引擎使用王乐作为应用服务器的基础。所有的逻辑都分层到王乐处理程序中，这些处理程序链接在一起形成一个管道。它与我们的Proxygen HTTP服务器通信以提供数据查询，并且节点之间相互通信。</p><p id="6ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使用共享相同(对称)二进制可执行文件的服务器网格，因此没有主/从范例。每个服务器都是一个节点，既作为主机又作为从机，并使用自定义的二进制数据协议相互传递数据/消息。</p><p id="2deb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要的唯一缺少的东西是<a class="ae jd" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel="noopener ugc nofollow" target="_blank">纤程</a>,用于引擎内存储和查询任务的协作调度；然而，富利/王乐开发商目前有一个实验版本，但它还没有准备好生产。</p><h2 id="9228" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak"> 2。硬件/劳动力成本</strong></h2><p id="5131" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">根据我们的HTTP基准测试，我量化了1个C++服务器大约相当于40个负载平衡的python服务器的原始计算能力。因此，使用C++真的可以从底层硬件中挤出所有的计算能力，节省1/40的服务器成本。我想我们可以一开始就用Python编写它，但是从经济上来说，这是对人力成本和时间的浪费，因为在某些阶段，我们不得不放弃它，用C++版本来获得我们需要的性能。Python代码一旦废弃就没有经济价值了。</p><p id="9c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，C++可能不是创业公司最受欢迎的选择，但我相信现代C++可以是一个可行的选择，给你接近C的性能和高层次的抽象。一旦代码库显著增长，我会担心构建时间，但希望C++17模块可以缓解这一问题。</p><p id="ec97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章能激励其他人探索C++。</p></div></div>    
</body>
</html>