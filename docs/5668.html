<html>
<head>
<title>Testing your Network logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试您的网络逻辑</h1>
<blockquote>原文：<a href="https://medium.com/swlh/testing-your-network-logic-ec61d999f03f?source=collection_archive---------2-----------------------#2018-07-22">https://medium.com/swlh/testing-your-network-logic-ec61d999f03f?source=collection_archive---------2-----------------------#2018-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="850d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们学习抽象业务逻辑，使其可测试；我们不再质疑视图模型或演示者应该进行单元测试，但是如果我说有更多的逻辑呢？你的网络逻辑呢？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/410c177d880062f0d5c776051feadc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*L4udrOmWQdoAyN3h.jpg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Network logic can get complex…</figcaption></figure><p id="b993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，Android开发者使用一种常见的设置，<strong class="ih jp">用<strong class="ih jp"> OkHttp </strong>和<strong class="ih jp"> Moshi </strong>或<strong class="ih jp"> Gson </strong>改造</strong>。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="6a9f" class="jv jw hi jr b fi jx jy l jz ka">val moshi = Moshi.Builder().build()<br/>val okHttp = OkHttpClient.Builder().build()<br/>val retrofit = Retrofit.Builder()<br/>        .addConverterFactory(MoshiConverterFactory.create(moshi))<br/>        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<br/>        .client(okHttp)<br/>        .baseUrl("Some url")<br/>        .build()</span></pre><p id="3de9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后一些需求开始进来</p><ul class=""><li id="c149" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated">跟踪网络事件。</li><li id="dd0e" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">为您的后端添加自定义标题。</li><li id="7bf6" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">认证令牌的刷新机制。</li><li id="01f8" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">还有更多…</li></ul><p id="1c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们受益于OkHttp机制，比如拦截器和认证器。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="b698" class="jv jw hi jr b fi jx jy l jz ka">val level = if (BuildConfig.<em class="kp">DEBUG</em>) {<br/>    HttpLoggingInterceptor.Level.BODY<br/>} else {<br/>    HttpLoggingInterceptor.Level.NONE<br/>}<br/>val loggingInterceptor = HttpLoggingInterceptor().setLevel(level)<br/><br/>val okHttp = OkHttpClient.Builder()<br/>        .addInterceptor(authTokenInterceptor)<br/>        .addInterceptor(loggingInterceptor)<br/>        .authenticator(authentiactor)<br/>        .build()</span></pre><p id="e25b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们把所有的放在一起，希望它能起作用。</p><p id="3d86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以为每个拦截器或验证器添加单元测试，但是我们能确定整个网络层的组合和设置工作正常吗？</p><p id="4d40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有没有想过在添加一个拦截器之前添加另一个会发生什么？或者我们改变适配器的顺序？</p><blockquote class="kq kr ks"><p id="0dc6" class="if ig kp ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">秩序很重要！</p></blockquote><p id="2bee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们可以测试所有的设置和网络层而不攻击服务器，会怎么样？</p><h1 id="e8b3" class="kw jw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> WebMockServer来拯救。</strong></h1><p id="f019" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">OkHttp不仅仅提供客户端库。如果我们检查回购协议，我们可以找到其他组件。那些<a class="ae ly" href="https://github.com/square/okhttp/tree/master/mockwebserver" rel="noopener ugc nofollow" target="_blank"> MockWebServer </a>中的一个。</p><blockquote class="kq kr ks"><p id="56f1" class="if ig kp ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">这个库使得测试你的应用程序在进行HTTP和HTTPS调用时做正确的事情变得容易。它允许您指定要返回的响应，然后验证请求是否按预期发出。</p></blockquote><p id="7cda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自述部分有一个很好的解释和一些例子，但下面我会解释谁使用它来测试我们的设置。</p><p id="a185" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们解释一下不同的概念:</p><ul class=""><li id="12de" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated"><strong class="ih jp"> MockWebServer: </strong>一个精简类，它将拦截HTTP请求并根据配置的响应进行回复。</li><li id="46f3" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih jp"> MockResponse: </strong>可配置OkHttp响应。(即设置HTTP代码、正文、标题……)</li><li id="663a" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">MockWebServer <strong class="ih jp">。enqueue(mockResponse): </strong>向队列中添加一个mockResponse，第一个请求将被第一个入队的响应所回复，第二个请求将被第二个响应所回复，依此类推…</li><li id="be94" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">MockWebServer <strong class="ih jp">。taker request():</strong>等待下一个HTTP请求，记录它，并将其返回到RecordedRequest中。</li><li id="96a9" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih jp"> RecordedRequest: </strong>包含来自HTTP请求的记录字段的类(即头、体、方法、路径……)</li></ul><p id="a2e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们目前需要的大部分东西，所以让我们设置我们的第一个测试。</p><p id="8b21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的做法是将上面解释的通用设置抽象成一个类，该类可用于生成我们的API接口，如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0fec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个类将被任何需要API的组件使用。</p><p id="e284" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们可以设置我们的测试类:</p><ol class=""><li id="169b" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc mb kh ki kj bi translated">创建<strong class="ih jp"> MockWebServer。</strong></li><li id="1764" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">使用mock web server<strong class="ih jp">生成</strong>URL，这样任何请求都会被转发到模拟服务器。</li><li id="1e1f" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">使用<strong class="ih jp">真正的</strong>实现你的拦截器和认证器。</li><li id="d768" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">使用<strong class="ih jp">模仿</strong>作为拦截器和验证器的依赖来验证它们。</li><li id="10a7" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">创建一个简单的<strong class="ih jp"> TestApi </strong>和<strong class="ih jp"> TestData </strong>来测试设置。</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="6084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经准备好了设置，我们需要定义测试什么。</p><ol class=""><li id="204c" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc mb kh ki kj bi translated"><strong class="ih jp">解析器</strong>:我们想要确保我们的Moshi设置是正确的</li><li id="52ef" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated"><a class="ae ly" href="https://github.com/square/okhttp/wiki/Interceptors" rel="noopener ugc nofollow" target="_blank"> <strong class="ih jp">拦截器</strong> </a>:我们希望确保当一个请求完成时，我们的拦截器的行为符合预期</li><li id="5f2d" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated"><a class="ae ly" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java" rel="noopener ugc nofollow" target="_blank"> <strong class="ih jp">验证者</strong> </a>:我们希望确保当返回401响应时，我们的验证者尝试刷新令牌并重试原始响应。</li><li id="2a20" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">(可选)<strong class="ih jp">“真正的”API接口</strong>:我们可以用一些假数据测试我们所有的端点和API，这样我们就可以验证我们所有的响应和请求体的解析</li></ol><h2 id="4021" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated">测试解析器</h2><p id="9e05" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">下面的代码显示了一个简单的解析测试示例，它验证了我们的Moshi和retrofit配置正确。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f152" class="jv jw hi jr b fi jx jy l jz ka">@Test<br/>fun `When succeed with valid data, Then response is parsed`() {<br/>    val testData = TestData("hello!")<br/>    val testDataJson = "{\"name\":\"${testData.name}\"}"<br/>    val successResponse<strong class="jr jp"> = </strong>MockResponse().setBody(testDataJson)<br/><strong class="jr jp">    mockWebServer.enqueue(successResponse)</strong><br/><br/>    val response = <strong class="jr jp">testApi.test().execute()</strong><br/><br/>    mockWebServer<strong class="jr jp">.takeRequest()</strong><br/>    assertThat(response.body()!!, <em class="kp">is</em>(testData))<br/>}</span></pre><ol class=""><li id="2769" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc mb kh ki kj bi translated">用一些JSON数据创建一个成功的MockResponse</li><li id="20c1" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">将响应排入队列</li><li id="afd3" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">调用API端点(HTTP请求)</li><li id="50ff" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">等待，直到请求得到处理</li><li id="161e" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">断言响应体被正确地解析到我们的数据类中</li></ol><h2 id="4269" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated">测试拦截器</h2><p id="2873" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">下一个测试将检查我们的<em class="kp"> AuthInterceptor </em>是否在我们的请求中添加了一个<em class="kp">载体</em>令牌头。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="80d4" class="jv jw hi jr b fi jx jy l jz ka">@Test<br/>fun `When a call is done, Then auth header is added`() {<br/>    val token = "Token"<br/>    tokenStorage.setToken(token)<br/><strong class="jr jp">    mockWebServer.enqueue(successResponse)</strong><br/><br/><strong class="jr jp">    testApi.test().execute()</strong><br/><br/>    val recordedRequest = <strong class="jr jp">mockWebServer.takeRequest()</strong><br/>    val header = recordedRequest.getHeader("authorization")<br/>    <em class="kp">assertThat</em>(header, <em class="kp">is</em>("Bearer $token"))<br/>}</span></pre><ol class=""><li id="3813" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc mb kh ki kj bi translated">将预期的令牌设置到我们的存储中(由AuthInterceptor使用)</li><li id="4dee" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">将响应排入队列</li><li id="d785" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">执行并等待记录的请求</li><li id="2a1b" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">断言标头“authorization”存在，并且包含预期的令牌</li></ol><h2 id="45d4" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated"><strong class="ak">测试认证器</strong></h2><p id="95ef" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">认证器可以用于几种情况(<a class="ae ly" href="https://github.com/square/okhttp/wiki/Recipes#Handling$authentication" rel="noopener ugc nofollow" target="_blank">参见OkHttp Recipes部分</a>)，在我们的例子中负责在服务器回复401时请求一个新令牌。</p><p id="b89d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能是我们设置中最关键的部分，也是最难测试的部分，因为我们希望确保用户不会被注销，并且能够在没有注意到的情况下刷新auth令牌。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8f09" class="jv jw hi jr b fi jx jy l jz ka">@Test<br/>fun `When fails with 401, Then authenticator refreshes token`() {<br/>    val invalidTokenResponse = MockResponse().setResponseCode(401)<br/>    val authResponse = AuthResponse(<br/>            accessToken = "New token", <br/>            expiresInSeconds = 0, <br/>            refreshToken = refreshToken<br/>    )<br/>    val responseBody = moshi.adapter(AuthResponse::class.<em class="kp">java</em>)<br/>            .toJson(authResponse)<br/>    val refreshResponse = MockResponse()<br/>            .setResponseCode(200)<br/>            .setBody(responseBody)<br/>    tokenStorage.refreshToken = refreshToken<br/><br/><em class="kp">    // Enqueue 401 response</em><br/><strong class="jr jp">    mockWebServer.enqueue(invalidTokenResponse)</strong><br/><em class="kp">    // Enqueue 200 refresh response</em><br/><strong class="jr jp">    mockWebServer.enqueue(refreshResponse)</strong><br/><em class="kp">    // Enqueue 200 original response</em><br/><strong class="jr jp">    mockWebServer.enqueue(successResponse)</strong><br/><br/>    val response = <strong class="jr jp">testApi.test().execute()</strong><br/><br/><strong class="jr jp">    mockWebServer.takeRequest()<br/>    mockWebServer.takeRequest()</strong><br/>    val retryRequest = <strong class="jr jp">mockWebServer.takeRequest()</strong><br/>    val header = retryRequest.getHeader("authorization")<br/>    <em class="kp">assertThat</em>(tokenStorage.token, <em class="kp">is</em>(authResponse.accessToken))<br/>    <em class="kp">assertThat</em>(header, <em class="kp">is</em>("Bearer ${oAuthResponse.accessToken}"))<br/>    <em class="kp">assertThat</em>(response.<em class="kp">isSuccessful</em>, <em class="kp">is</em>(true))<br/>}</span></pre><ol class=""><li id="822e" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc mb kh ki kj bi translated">用401代码设置失败响应</li><li id="66da" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">使用新的身份验证令牌设置刷新响应</li><li id="e338" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">将有序的响应集排队</li><li id="8c94" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">执行并等待所有三个请求</li><li id="3e36" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc mb kh ki kj bi translated">检查标头是否有新令牌，以及令牌是否存储正确</li></ol><p id="9e3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以越来越深入地了解不同的边缘案例，例如:</p><ul class=""><li id="510c" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated">当刷新调用失败时，原始请求失败，返回401。</li><li id="735d" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">当刷新调用以401失败时，则不会再次调用刷新调用。</li><li id="6355" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">当多个调用因401而失败时，则只进行一次刷新调用。</li><li id="cd35" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi">…</li></ul><h1 id="c399" class="kw jw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="7285" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">使用MockWebServer测试网络并不困难，网络层是您的应用程序的一个非常重要的部分，服务器端是不可预测的，并且很难验证手动测试的所有情况。</p><h2 id="dca8" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated">外卖食品</h2><ul class=""><li id="5731" class="kb kc hi ih b ii lt im lu iq mp iu mq iy mr jc kg kh ki kj bi translated"><strong class="ih jp">摘要</strong>创建你的网络组件。</li><li id="32b6" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">使用<strong class="ih jp"> MockWebServer </strong>测试你的网络层。</li><li id="1afe" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">在<strong class="ih jp">设置</strong>上创建MockWebServer(它会自动启动)。</li><li id="2c81" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih jp">用mock web server<br/><em class="kp">(val httpUrl = mock web server . URL(base URL))</em>的实例创建</strong>基本<strong class="ih jp"> URL </strong></li><li id="1212" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih jp"> MockResponse </strong>带有一个<strong class="ih jp">空体</strong>，你的系统能处理吗？</li><li id="b2c2" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated"><strong class="ih jp"> Enqueue </strong>和<strong class="ih jp">taker request</strong>默认是有序的，使用自己的<a class="ae ly" href="https://github.com/square/okhttp/tree/master/mockwebserver#dispatcher" rel="noopener ugc nofollow" target="_blank"> <strong class="ih jp"> Dispatcher </strong> </a>进行自定义行为。</li><li id="6bce" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">测试所有API或创建测试API。</li></ul></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><div class="je jf jg jh fd mz"><a href="https://github.com/marcelpinto" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="hj b fi z dy ne ea eb nf ed ef hh bi translated">marcelpinto -概述</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">arctic Code Vault Contributor rx Flux是一个小框架，以便使用RxJava遵循Flux设计模式…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jj mz"/></div></div></a></div></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es no"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="48f8" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated">这个故事发表在<a class="ae ly" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的企业家出版物，拥有348，974+人。</h2><h2 id="24b8" class="jv jw hi bd kx mc md me lb mf mg mh lf iq mi mj lj iu mk ml ln iy mm mn lr mo bi translated">在这里订阅接收<a class="ae ly" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es no"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>