<html>
<head>
<title>Tic Tac Toe at the Monte Carlo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特卡洛的井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/swlh/tic-tac-toe-at-the-monte-carlo-a5e0394c7bc2?source=collection_archive---------2-----------------------#2018-01-17">https://medium.com/swlh/tic-tac-toe-at-the-monte-carlo-a5e0394c7bc2?source=collection_archive---------2-----------------------#2018-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bea7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">创建一个使用蒙特卡罗树搜索算法的井字游戏人工智能。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b08ac9355131365e4813cacdfc3b016b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9PuhqeberSSYYECJROl8Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Picture from Alex Knight</figcaption></figure><p id="9194" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">井字游戏，像其他回合制游戏一样，信息不被隐藏，游戏机制不依赖于运气，是一个完美的信息游戏。这种类型的游戏允许每个玩家预测某人行动的所有可能结果。由于该游戏是完全确定的，因此可以用该游戏的所有可能结果来构建一棵树，该树的每个节点被赋予一个值，该值确定每个玩家的胜率或损失率。</p><p id="d848" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，人工智能可以遍历这棵树，选择它认为最有可能导致胜利的节点。如果人工智能选择节点的策略是挑选丢失可能性最小的节点，那么它将利用极大极小策略。虽然在理论上这听起来像一个可行的游戏计划，但在实践中，渲染一个完整的游戏树，然后遍历它的时间可能是不现实的，特别是对于像围棋这样有大量可能的移动(高分支因子)的游戏。这就是蒙特卡罗树搜索算法的用武之地。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="db24" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">蒙特卡罗树搜索(MCTS)是一种启发式搜索算法，用于大量的游戏人工智能。其中最引人注目的是围棋人工智能，阿尔法围棋。MCTS在具有高分支因子的游戏中大放异彩，因为与需要完整博弈树的极大极小不同，MCTS可以被配置为在期望的时间量后停止，并可以基于部分构建的博弈树选择足够最优的解决方案。虽然纯粹的蒙特卡罗过程会运行大量随机模拟的游戏状态，但MCTS保留每个节点的统计数据，然后将置信上限(UCB)算法应用于节点的统计数据。</p><p id="ce19" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">UCB函数确定每个节点胜率的置信区间，并返回置信区间中的最高值。该函数也给予具有更多模拟的节点更窄的置信区间，同时扩大具有更少模拟的节点的置信区间。MCTS算法选择具有最高UCB值的节点来运行其模拟，结果，尽管具有高置信区间上限的节点最初可能被选择多次，但是具有较少模拟的其他节点将具有越来越宽的置信区间。随着置信区间的增长，它们的上界可能会高于最初有希望的节点的上界。通俗地说，随着我们测试一个节点的次数越来越多，我们对其支出的信心就变得越来越确定。我们对它的收益变得更加确定，并且可以缩小我们对它的置信区间。我们对较少模拟的节点变得不太有信心，并扩大它们的置信区间以反映我们的不确定性。</p><p id="3ada" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">UCB公式通过确保没有潜在节点会缺乏模拟播放，但同时确保有利的分支比它们的对应分支播放得更频繁，来平衡探索/利用问题。我们将使用的UCB公式如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kr"><img src="../Images/0ac85e01a198360719abcccd3dc3a09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*Miishv65b3NzFN4mHl6ivQ.png"/></div></figure><ul class=""><li id="0e7a" class="ks kt hi jp b jq jr jt ju jw ku ka kv ke kw ki kx ky kz la bi translated"><strong class="jp lb"> w </strong>代表第I步后该节点的模拟获胜次数。</li><li id="392f" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated"><strong class="jp lb"> n </strong>代表在第I次移动后该节点已经发生的模拟次数。</li><li id="900e" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated"><strong class="jp lb"> c </strong>代表勘探参数。我们将使用√2。</li><li id="1b2b" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated"><strong class="jp lb"> t </strong>代表I移动后发生的模拟总数。</li></ul><p id="7a72" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp lb">等式的第一部分对应于剥削</strong>。赢的次数越多=赢的比率越高=等式第一部分的数字越大。<strong class="jp lb">等式的第二部分对应于探索</strong>。大量的总仿真和少量的该节点的仿真将导致等式的第二部分的更大数量。UCB函数的两个部分一起在优先考虑有希望的节点和探索未访问的节点之间建立了平衡。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="07d1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">MCTS有四个基本阶段:<em class="kj">选择</em>、<em class="kj">扩展</em>、<em class="kj">模拟</em>和<em class="kj">反向传播</em>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/abd06e0ce9543767e41105232218faac.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*JL2qkJKbXGABHN3-8v8koA.png"/></div></figure><p id="b85a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<strong class="jp lb">选择</strong>中，我们从根节点<strong class="jp lb"> R </strong>开始，选择具有最高UCB值的连续子节点，直到我们到达没有更多子节点的节点<strong class="jp lb"> L </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/f35d2475daf17fa157444060523a7a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*KoEOdVECKDrzjH9g0DjZyg.png"/></div></figure><p id="692f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">除非<strong class="jp lb"> L </strong>节点导致结束游戏的游戏状态，否则我们将进入<strong class="jp lb">扩展</strong>阶段，从该游戏状态创建所有可能的结果，并随机选择<strong class="jp lb"> L </strong>的子节点<strong class="jp lb"> C </strong>中的一个。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/544dce8881aeb5a97d6b166d92b2bd9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*MdCzozecK3fLHbUijJ7Uuw.png"/></div></figure><p id="912c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在下一阶段，<strong class="jp lb">模拟</strong>，我们从节点<strong class="jp lb"> C </strong>到游戏结束状态(赢、输、平)生成随机播放。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/5cf87955eb306ef7c324225feb61163c.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*ch4aq-ec3WAun1A3FBYumA.png"/></div></figure><p id="4436" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们使用在<strong class="jp lb">反向传播</strong>期间产生的游戏状态来更新从<strong class="jp lb"> C </strong>到<strong class="jp lb"> R </strong>的节点内的信息，以确定新的播出是赢、输还是平。</p><p id="9226" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">总的来说，它看起来像:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/1238557acae4e7f9ac8a85a9f0eb00e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Avecss5kgQ60GoHe9I5zZg.png"/></div></div></figure><p id="9afd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该算法将循环通过所有4个阶段，直到分配的时间已经过去。之后，它将选择具有最高访问量的根的子节点，因为更多的访问等于更多的选择，这仅在它具有最高UCB值时发生。然后在游戏的每一回合重复这一过程。</p><p id="1ad5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我现在将展示一个用Javascript构建的MCTS的例子。这只是一个通用的游戏玩法，可以为任何回合制游戏量身定制。特别是在这种情况下，该算法将用于井字游戏人工智能。虽然井字游戏比围棋小得多，分支因素也小得多，但它们使用的是相同的原理。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="8432" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">MCTS的主要目标是在你当前的状态下找到最好的可能的移动。为了达到这个目标，我们应该创建一个名为findNextMove的函数。稍后我将解释下面函数的每一部分。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c51b" class="lo lp hi lk b fi lq lr l ls lt">findNextMove(board, playerNo) {<br/>  let opponent = 3 - playerNo;<br/>  let tree = new Tree();<br/>  let rootNode = tree.root;<br/>  rootNode.state.board = new Board(board);<br/>  rootNode.state.playerNo = opponent;</span><span id="8849" class="lo lp hi lk b fi lu lr l ls lt">  let startTime = Date.now();<br/>  while ((Date.now() - startTime) &lt; 1000) {<br/>    let promisingNode = selectPromisingNode(rootNode);<br/>    <br/>    if (promisingNode.state.board.checkStatus() === IN_PROGRESS) {<br/>      expandNode(promisingNode);<br/>    }</span><span id="0392" class="lo lp hi lk b fi lu lr l ls lt">    let nodeToExplore = promisingNode;<br/>    if (nodeToExplore.childArray.length &gt; 0) {<br/>      nodeToExplore = promisingNode.getRandomChild();<br/>    }</span><span id="0e39" class="lo lp hi lk b fi lu lr l ls lt">    let playoutResult = simRanPlayout(nodeToExplore, opponent)<br/>    backpropagation(nodeToExplore, playoutResult);<br/>  }</span><span id="9340" class="lo lp hi lk b fi lu lr l ls lt">  let winnerNode = rootNode.getChildWithMaxScore();<br/>  return winnerNode.state.board;<br/>}</span></pre><p id="e782" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们首先定义什么是节点、状态和板。棋盘是一个对象，它记录棋盘的大小、已经玩过的棋子以及游戏的位置和价值。节点对象跟踪状态，状态是跟踪棋盘、当前玩家、节点被访问的次数和节点的获胜分数的对象。</p><p id="c615" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们寻找最优移动所需要的基本信息是棋盘的状态以及轮到谁了，这两个信息都是通过函数的参数提供给函数的。然后，该函数创建它将要遍历的树。该树的根节点将具有电路板的当前状态。</p><p id="eed4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，该函数进入while循环，运行一段设定的时间。我们允许它运行的时间越长，我们对人工智能的下一步行动就越有信心。你可以在while循环中看到MCTS的四个阶段。</p><ul class=""><li id="02d7" class="ks kt hi jp b jq jr jt ju jw ku ka kv ke kw ki kx ky kz la bi translated">选择阶段= selectPromisingNode()</li><li id="5717" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated">扩展阶段= expandNode()</li><li id="b1b2" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated">模拟阶段= simRanPlayout()</li><li id="e9be" class="ks kt hi jp b jq lc jt ld jw le ka lf ke lg ki kx ky kz la bi translated">反向传播相位=反向传播()</li></ul><p id="d842" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们扩展selectPromisingNode函数。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="07c6" class="lo lp hi lk b fi lq lr l ls lt">selectPromisingNode(rootNode) {<br/>  let node = rootNode;<br/>  while (node.childArray.length !== 0) {<br/>    node = UCB.findBestNodeWithUCB(node);<br/>  }<br/>  return node;<br/>}</span></pre><p id="060f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个函数中，我们从根节点开始遍历树，并找到它下面最有希望的叶节点。这通过查看每个子节点的UCB值并选择具有最高值的节点来实现。重复该过程，直到一个节点不再有子节点。计算UCB值的函数如下。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="12c3" class="lo lp hi lk b fi lq lr l ls lt">UCB = {</span><span id="4c0d" class="lo lp hi lk b fi lu lr l ls lt">  findBestNodeWithUCB: (node) =&gt; {<br/>    let parentVisitCt = node.state.visitCount;<br/>    let childUCB = [];<br/>    node.childArray.forEach(child =&gt; {<br/>      childUCB.push(UCB.ucbValue(parentVisitCt, child.state.winScore, child.state.visitCount));<br/>    }</span><span id="faaf" class="lo lp hi lk b fi lu lr l ls lt">    let max = Math.max(...childUCB);<br/>    let idx = childUCB.indexOf(max);<br/>    return node.childArray[idx];</span><span id="eba3" class="lo lp hi lk b fi lu lr l ls lt">  };</span><span id="c4c9" class="lo lp hi lk b fi lu lr l ls lt">ucbValue: (totalVisit, nodeWinScore, nodeVisit) =&gt; {</span><span id="86f4" class="lo lp hi lk b fi lu lr l ls lt">    if (nodeVisit === 0) {<br/>      return Number.MAX_SAFE_INTEGER;<br/>    }<br/>    return (nodeWinScore / nodeVisit) + 1.41 * Math.sqrt ( Math.log (totalVisit) / nodeVisit);<br/>  }</span><span id="a73d" class="lo lp hi lk b fi lu lr l ls lt">}</span></pre><p id="05a2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对应于上面的UCB公式，我们使用来自其父节点的总访问次数<strong class="jp lb"> t </strong>，当前节点已经生成的模拟获胜次数<strong class="jp lb"> w </strong>，以及该节点已经被选择的次数<strong class="jp lb"> n </strong>，来找到UCB值。如果这个节点以前从未被访问过，我们给它取一个最大的整数来增加它被选中的机会。这确保了每个节点至少被模拟一次。findBestNodeWithUCB函数为每个子节点生成一个UCB值，并返回具有最高值的子节点。</p><p id="36fa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们选择了将要使用的节点，我们就检查游戏板的状态。如果游戏仍在进行，checkStatus函数返回-1，如果结果是平局，返回0，或者根据哪个玩家赢了游戏，返回1和2。如果游戏状态是非游戏结束状态，-1，那么我们将进入资料片阶段。我们来看看expandNode函数。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c661" class="lo lp hi lk b fi lq lr l ls lt">expandNode(node) {</span><span id="c986" class="lo lp hi lk b fi lu lr l ls lt">  let possibleStates = node.state.getAllPossibleStates();</span><span id="a352" class="lo lp hi lk b fi lu lr l ls lt">  possibleStates.forEach(state =&gt; {<br/>    let newNode = new Node(state);<br/>    newNode.parent = node;<br/>    newNode.state.playNo = node.state.getOpponent();<br/>    node.childArray.push(newNode);<br/>  });</span><span id="66c1" class="lo lp hi lk b fi lu lr l ls lt">}</span></pre><p id="e81e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该函数首先从当前节点状态中找到所有可能的结果。然后，它用当前状态的每个可能的移动创建一个节点，并将其推入当前节点的子数组。虽然扩张看起来是一个非常浮夸的术语，但是这个阶段非常简单。它只是用可能的游戏状态填充childArray，除非选择的节点是具有结束游戏状态的节点。算法中的下一行:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="3ea5" class="lo lp hi lk b fi lq lr l ls lt">let nodeToExplore = promisingNode;<br/>if (nodeToExplore.childArray.length &gt; 0) {<br/>  nodeToExplore = promisingNode.getRandomChild();<br/>}</span></pre><p id="c9c4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">检查当前数组是否有任何可能的子节点，并随机选择一个节点来运行它的模拟游戏。模拟游戏是在simulateRandomPlayout函数中完成的。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="d0a1" class="lo lp hi lk b fi lq lr l ls lt">simulateRandomPlayout(node, opponent) {</span><span id="de66" class="lo lp hi lk b fi lu lr l ls lt">  let tempNode = new Node(null, node);<br/>  let tempState = tempNode.state;<br/>  let boardStatus = tempState.board.checkStatus();</span><span id="8fc1" class="lo lp hi lk b fi lu lr l ls lt">  if (boardStatus === opponent) {<br/>    tempNode.parent.state.winScore = Number.MIN_SAFE_INTEGER;<br/>    return boardStatus;<br/>  }</span><span id="9705" class="lo lp hi lk b fi lu lr l ls lt">  while(boardStatus === board.IN_PROGRESS) {<br/>    tempState.togglePlayer();<br/>    tempState.randomPlay();<br/>    boardStatus = tempState.board.checkStatus();<br/>  }<br/>  return boardStatus;</span><span id="1341" class="lo lp hi lk b fi lu lr l ls lt">}</span></pre><p id="f941" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，该函数首先检查节点的电路板，以查看其状态。如果节点导致对手的胜利，这将意味着如果玩家进行了选定的移动，他的对手将有一个后续的移动，可以导致对手立即胜利。因为玩家选择的移动可能导致一定的损失，所以该函数将父节点的winScore降低到尽可能低的整数，以防止将来移动到该节点。否则，该算法在两个玩家之间交替随机移动，直到棋盘导致游戏结束状态。该函数然后返回最终的游戏状态。</p><p id="a60a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">MCTS的最后一步是反向传播。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="325d" class="lo lp hi lk b fi lq lr l ls lt">backpropagation(nodeToExplore, playoutResult) {<br/>  let tempNode = nodeToExplore;<br/>  while (tempNode !== undefined) {<br/>    tempNode.state.visitCount++;<br/>    if (tempNode.state.playNo === playoutResult) {<br/>      tempNode.state.addScore(10);<br/>    }<br/>    tempNode = tempNode.parent;<br/>  }<br/>}</span></pre><p id="e28f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，我们从选择的叶节点的子节点返回到根节点。在这个过程中，我们增加了节点的visitCount。如果我们从simulateRandomPlayout的返回中得到的Playout结果等于我们正在模拟的玩家数量，那么我们将增加每个节点的获胜分数。然后，在计算UCBs时，这些更新的统计用于选择阶段的下一次迭代。</p><p id="af18" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这些步骤按照我们指定的时间运行，在本例中是1000毫秒或1秒。一旦时间用完，我们选择具有最多访问计数的根的子节点，因为只有当节点具有最高的UCB时它才会被访问，这在理论上意味着移动将导致最高的胜利机会。</p><p id="b7e4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以用下面的函数来测试我们的算法，该函数模拟两个人工智能之间的井字游戏:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="a655" class="lo lp hi lk b fi lq lr l ls lt">simulateAIPlay() {<br/>  let board = new Board();<br/>  let player = 1;<br/>  let totalMove = 9;<br/>  for (var i = 0; i &lt; totalMove; i++) {<br/>    board = findNextMove(board, player);<br/>    if (board.checkStatus() !== -1) {<br/>      break;<br/>    }<br/>    player = 3 - player;<br/>  }<br/>  let winStatus = board.checkStatus();<br/>  return winStatus;<br/>}</span></pre><p id="2c04" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由于两个人工智能都在使用这个超级棒的算法，并且都将选择最佳的移动，每场比赛都将产生平局。</p><p id="7adc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在这里查看我的完整代码。</p><p id="ee52" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">非常感谢这篇<a class="ae lv" href="http://www.baeldung.com/java-monte-carlo-tree-search" rel="noopener ugc nofollow" target="_blank">文章</a>帮我创建了MCTS函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure><h2 id="fd41" class="lo lp hi bd lx ly lz ma mb mc md me mf jw mg mh mi ka mj mk ml ke mm mn mo mp bi translated">这篇文章发表在<a class="ae lv" href="https://medium.com/swlh" rel="noopener">《创业</a>》上，这是Medium最大的创业刊物，有286，184+人关注。</h2><h2 id="7945" class="lo lp hi bd lx ly lz ma mb mc md me mf jw mg mh mi ka mj mk ml ke mm mn mo mp bi translated">订阅接收<a class="ae lv" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/731acf26f5d44fdc58d99a6388fe935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfnVvkMRFtjVsWF7vkClA.png"/></div></div></figure></div></div>    
</body>
</html>